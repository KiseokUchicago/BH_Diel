---
title: "peptide_level_visualization"
author: "KiseokUchicago"
date: "2021-02-22"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: console
---

```{r global_options, include=FALSE}
knitr::opts_chunk$set(fig.width=11, fig.height=9,
                      error=TRUE, echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE)
```

### Peptide level visualization

```{r}
# libraries
library(dplyr)
library(tidyr)
library(stringr)
library(ggplot2)
library(formattable)
```

### 1. Quality check: Number of uniq peptides (sequence) per sample

```{r}
# read in combined table of 24 samples (Replicate B)
df_pep <- read.table("Replicate_ABC67_combined.tsv",sep='\t',header = T)

# count unique peptide per sample
df_uni <- df_pep %>% group_by(SampleID) %>% summarize(uniq_pep = length(unique(Base.Peptide.Sequence)))
df_uni1 <- df_uni %>% separate(SampleID, sep='_', into= c('Depth','Time','Replicate'),remove = F)
df_uni2 <- df_uni1 %>% arrange(desc(Depth))

# get the order right from SRF -> DCL -> BDCL
ord <- df_uni2$SampleID 
df_uni2$SampleID <- factor(df_uni2$SampleID, levels = ord)
df_uni2$Depth <- factor(df_uni2$Depth, levels = c('SRF','DCL','BDCL'))

# Making barplot
theme_set(theme_bw())
cols <- c('SRF'='#fc8d62','DCL'='#66c2a5','BDCL'='#8da0cb')
uniq1 <- ggplot(df_uni2, aes(x=SampleID, fill=Depth, y=uniq_pep)) +  ## I put fill=value which was wrong
  geom_bar(stat="identity") +
  scale_fill_manual(values=cols) +
  ylab("Number of unique peptide sequence \n") +
  xlab("\n SampleID") +
  ggtitle("Number of unique peptide sequences per sample")+
  ## adjust positions
  theme(plot.title = element_text(size = 20,hjust = 0.5, family="serif")) + 
  theme(axis.title.x = element_text(size = 15,hjust = 0.5, family="serif")) + 
  theme(axis.title.y = element_text(size = 15,hjust = 0.5, family="serif")) + 
  theme(axis.text.x = element_text(angle = 90, hjust = 0.5, vjust=0.3,size=13, family="serif"))+
  theme(axis.text.y = element_text(size=10))+
  theme(panel.grid.major = element_blank()) +
  theme(panel.grid.minor = element_blank())

uniq2 <- uniq1 + geom_text(aes(x=df_uni$SampleID, y=df_uni$uniq_pep, label=df_uni$uniq_pep),
            size = 3, hjust = 0.5, position = position_stack(vjust = +1.05), family="serif")
uniq2
```

sample DCL_T8 doesn't seem to have good quality MS data. \ 
DCL_T8_A was added and now it seems okay.

### 1.1. Unique number of peptides per timepoint
Are there any differences across time points? \
Nope.

```{r}
# get # of unique peptides
df_uniq <- df_pep %>% group_by(Time,Depth) %>% summarize(uniq_pep = length(unique(Base.Peptide.Sequence)))
df_uniq1 <- df_uniq %>% arrange(desc(Depth))

# get the order right from SRF -> DCL -> BDCL
df_uniq1$Depth <- factor(df_uniq1$Depth, levels = c('SRF','DCL','BDCL'))

# Making barplot
theme_set(theme_bw())
cols <- c('SRF'='#fc8d62','DCL'='#66c2a5','BDCL'='#8da0cb')
time1 <- ggplot(df_uniq1, aes(x=Time, fill=Depth, y=uniq_pep)) +  ## I put fill=value which was wrong
  geom_bar(stat="identity",position="dodge") +
  scale_fill_manual(values=cols) +
  ylab("Number of unique peptide sequence \n") +
  xlab("\n SampleID") +
  ggtitle("Number of unique peptide sequences per timepoint (including all replicates)")+
  ## adjust positions
  theme(plot.title = element_text(size = 20,hjust = 0.5, family="serif")) + 
  theme(axis.title.x = element_text(size = 15,hjust = 0.5, family="serif")) + 
  theme(axis.title.y = element_text(size = 15,hjust = 0.5, family="serif")) + 
  theme(axis.text.x = element_text(hjust = 0.5, vjust=0.3,size=13, family="serif"))+
  theme(axis.text.y = element_text(size=10))+
  theme(panel.grid.major = element_blank()) +
  theme(panel.grid.minor = element_blank())

time1

```


### 2. Number of accumulative uniq peptides (sequence): Does it saturate?

```{r}
# read in combined table of 24 samples (Replicate B)
df_pep <- read.table("Replicate_ABC67_combined.tsv",sep='\t',header = T)

# get unique peptides per sample
dt <- df_pep %>% select(SampleID, Base.Peptide.Sequence) %>% unique()
# change SampleID into number
dt1 <- dt %>% select(SampleID) %>% unique() %>% arrange(SampleID) %>%  arrange()
dt2 <- tibble::rownames_to_column(dt1,"depth")
# merge dt and dt2
dt_depth <- left_join(dt,dt2,by=c('SampleID'='SampleID'))
dim(dt_depth)

# get cumulative number of unique peptides (https://stackoverflow.com/questions/15698399/cumulative-count-of-unique-values-in-r)
require(data.table)
dt_depth <- as.data.table(dt_depth)
setkey(dt_depth, "depth")
dt_depth[, Base.Peptide.Sequence := as.numeric(factor(Base.Peptide.Sequence, levels = unique(Base.Peptide.Sequence)))]
setkey(dt_depth, "depth", "Base.Peptide.Sequence")
dt.out <- dt_depth[J(unique(depth)), mult="last"]
dt.out[, Base.Peptide.Sequence := cummax(Base.Peptide.Sequence)]

# getting ready to make plot
df.out <- tibble::rowid_to_column(dt.out) 
df.out2 <- df.out %>% select(rowid, Base.Peptide.Sequence) %>% rename(value=Base.Peptide.Sequence) ## 3366 unique peptides
# Making line plot
theme_set(theme_bw())

p1 <- ggplot(df.out2,aes(x = rowid,y = value)) + geom_line(col="magenta") + geom_point(color='maroon') +
  ylab("Number of cumulative unique peptide sequence \n") +
  xlab("\n Number of cumulative samples") +
  # ylim(c(0,2200)) +
  ggtitle("Number of cumulative unique peptide sequences \n")+
  ## adjust positions
  theme(plot.title = element_text(size = 20,hjust = 0.5, family="serif")) + 
  theme(axis.title.x = element_text(size = 15,hjust = 0.5, family="serif")) + 
  theme(axis.title.y = element_text(size = 15,hjust = 0.5, family="serif")) + 
  theme(axis.text.x = element_text(hjust = 0.5, vjust=0.3,size=13, family="serif"))+
  theme(axis.text.y = element_text(size=10))
  # theme(panel.grid.major = element_blank())
  # theme(panel.grid.minor = element_blank())

p1


```
It seems to saturate as more samples are added.


### 3. Which Peptide_ids are present in all(almost) time points?
Make a histogram of x-axis being the # of time points present, y-axis being the number of Peptide_ids \
We need 3 histogram for (1) Surface, (2) DCL, and (3) BDCL

```{r}
# read in combined table of 24 samples (Replicate B)
df_pep <- read.table("Replicate_ABC67_combined.tsv",sep='\t',header = T)

# (1) Surface
colnames(df_pep)
df_srf <- df_pep %>% filter(Depth == 'SRF') %>% select(Peptide_id, SampleID, Time, Depth) %>% unique() %>% arrange(Peptide_id)
# How many time points did it appear
(df_srf2 <- df_srf %>% group_by(Peptide_id) %>% summarize(Timepoints = n_distinct(Time)) %>% ungroup())
# Check if Pep_1 appeared in 8 time points
df_srf %>% filter(Peptide_id=="Pep_1004") # true 8 times
# Histogram
theme_set(theme_bw())
ggplot(df_srf2, aes(Timepoints)) + geom_bar() +
  ylab("Number of peptides \n") +
  xlab("\n Cumulative number of timepoints peptide are present") +
  scale_x_continuous(breaks=seq(1,8,1))+
  ggtitle("Distribution of number of timepoints each Peptide_id appears (Surface) \n")+
  ## adjust positions
  theme(plot.title = element_text(size = 20,hjust = 0.5, family="serif")) + 
  theme(axis.title.x = element_text(size = 15,hjust = 0.5, family="serif")) + 
  theme(axis.title.y = element_text(size = 15,hjust = 0.5, family="serif")) + 
  theme(axis.text.x = element_text(hjust = 0.5, vjust=0.3,size=13, family="serif"))+
  theme(axis.text.y = element_text(size=10))
  # theme(panel.grid.major = element_blank())
  # theme(panel.grid.minor = element_blank())

# Let's try to plot all of them at once
df_all <- df_pep %>% select(Peptide_id, SampleID, Time, Depth) %>% unique() %>% arrange(Peptide_id)
# How many time points did it appear
(df_all2 <- df_all %>% group_by(Peptide_id, Depth) %>% summarize(Timepoints = n_distinct(Time)) %>% ungroup())
df_all2$Depth <- factor(df_all2$Depth, levels = c('SRF','DCL','BDCL'))

# Histogram
ggplot(df_all2, aes(Timepoints)) + geom_bar(aes(fill=Depth), position='dodge') +
  scale_fill_manual(values=cols) +
  ylab("Number of peptides \n") +
  xlab("\n Cumulative number of timepoints peptide are present") +
  scale_x_continuous(breaks=seq(1,8,1))+
  ggtitle("Distribution of number of timepoints each Peptide_id appears \n")+
  ## adjust positions
  theme(plot.title = element_text(size = 20,hjust = 0.5, family="serif")) + 
  theme(axis.title.x = element_text(size = 15,hjust = 0.5, family="serif")) + 
  theme(axis.title.y = element_text(size = 15,hjust = 0.5, family="serif")) + 
  theme(axis.text.x = element_text(hjust = 0.5, vjust=0.3,size=13, family="serif"))+
  theme(axis.text.y = element_text(size=10))
  # theme(panel.grid.major = element_blank())
  # theme(panel.grid.minor = element_blank())


```

### 3.2. For the peptides that show up only in 1 time point


```{r}
# filter peptides that appear only once
df_once <- df_all2 %>% filter(Timepoints ==1)
# innerjoin to get only the peptide_id from above (that appear once)
df_norep <- df_all %>% select(-SampleID) %>% unique() # get unique peptide_id per Sample (not replicate)
df_once2 <- inner_join(df_norep,df_once,by=c("Depth"="Depth","Peptide_id"="Peptide_id"))
df_once2$Depth <- factor(df_once2$Depth, levels = c('SRF','DCL','BDCL'))


# Histogram
theme_set(theme_bw())
ggplot(df_once2, aes(Time)) + geom_bar(aes(fill=Depth), position='dodge') +
  scale_fill_manual(values=cols) +
  ylab("Number of unique peptides \n") +
  xlab("\n Sampling Timepoint") +
  # scale_x_continuous(breaks=seq(1,8,1))+
  ggtitle("For peptide_ids detected once, in what timepoint is it detected? \n")+
  ## adjust positions
  theme(plot.title = element_text(size = 20,hjust = 0.5, family="serif")) + 
  theme(axis.title.x = element_text(size = 15,hjust = 0.5, family="serif")) + 
  theme(axis.title.y = element_text(size = 15,hjust = 0.5, family="serif")) + 
  theme(axis.text.x = element_text(hjust = 0.5, vjust=0.3,size=13, family="serif"))+
  theme(axis.text.y = element_text(size=10))
  # theme(panel.grid.major = element_blank())
  # theme(panel.grid.minor = element_blank())

```
In the surface and deep chlorophyll layer at T1 and T7, the numbers seem to surge. \
This is when the sun is at its peak.

### 4. Plotting time series fluctuation for the peptides
First retrieve the log abundance_ratio value for all peptides (average over the same spec_id)

```{r}
# (1) Get list of peptides that are present in 7 or 8 timepoints
df_all2_filt <- df_all2 %>% filter(Timepoints > 6) %>% unique() 

# (2) Let's average the abundance_ratio for each unique peptide
df_int <- df_pep %>% select(Peptide_id, Spec_id, cent.log2.16O.18O.Ratio, SampleID, Time, Depth, Replicate) %>%
  unique() %>% arrange(Peptide_id)
head(df_int)
df_int %>% filter(Peptide_id=='Pep_1' & Time =='T1' & SampleID == 'BDCL_T1_A')
# first average the spectrum_id per sample 
# important to make sure to take the mean of the log raio (instead of taking log2 after averaging the original value(2^x))
df_ave <- df_int %>% group_by(SampleID, Time, Depth, Replicate, Peptide_id) %>%
  summarize(Mean_abundance_ratio=mean(cent.log2.16O.18O.Ratio),
            SD_pep=sd(cent.log2.16O.18O.Ratio)) %>% ungroup()
head(df_ave)
df_ave %>% filter(Peptide_id=='Pep_1' & Time =='T1',Depth=="BDCL") # check

# Now, average and error by replicate
# see here for calculating error bar in log scale (https://faculty.washington.edu/stuve/log_error.pdf)
# but here we will not use the method in the link above
# calculate average and error bar for abundance_ratio
# SE calculated with Jake Waldbauer's method: sqrt(se(Mean_abundance_ratio)^2 +(mean(SD_pep))^2))
# standard error
se <- function(x) sd(x)/sqrt(length(x))
df_ave_rep <- df_ave %>% group_by(Time, Depth, Peptide_id) %>%
  summarize(Ave_abundance_ratio=mean(Mean_abundance_ratio),
            SE_abundance_ratio=sqrt((se(Mean_abundance_ratio))^2 +(mean(SD_pep))^2)) %>% ungroup()
head(df_ave_rep,10)
# why is there no sd for Pep_1004?
df_ave %>% group_by(SampleID) %>% filter(Peptide_id=='Pep_1003') # there is only 1 sample for T1 BDCL 

df_ave_rep2 <- df_ave_rep %>% mutate(error_up=Ave_abundance_ratio+SE_abundance_ratio) %>%
  mutate(error_down=Ave_abundance_ratio-SE_abundance_ratio)

head(df_ave_rep2)

# (3) import time metadata and merge
(df_time <- read.table('data/Time_metadata.txt', header=T, sep='\t'))
df_time$date_time <- str_replace(df_time$date_time, "/2019"," ")
df_time$date_time <- str_replace(df_time$date_time, ":00$","")

# left_join with average data
df_ave2 <- df_ave_rep2 %>% left_join(df_time, by=c('Time'='timepoint'))
head(df_ave2)
# only use peptides that appear 7 or 8 times
df_ave2 %>% select(Peptide_id) %>% unique() %>% dim() # 3233 peptides before
df_filt78 <- inner_join(df_ave2, df_all2_filt, by=c('Peptide_id'='Peptide_id','Depth'='Depth'))

# inspecting if the inner join was successful
head(df_filt78)
colnames(df_ave2)
colnames(df_time)
colnames(df_filt78)

df_filt78 %>% select(Peptide_id) %>% unique() %>% dim() # 841 peptides for peptides in 7 or 8 timepoints
df_filt78$Depth <- factor(df_filt78$Depth, levels = c('SRF','DCL','BDCL'))

# get only 8 ones
df_filt8 <- df_filt78 %>% filter(Timepoints > 7)
df_filt8 %>% select(Peptide_id) %>% unique() %>% dim() # 661 peptides for peptides in all 8 timepoints
df_filt8$Depth <- factor(df_filt8$Depth, levels = c('SRF','DCL','BDCL'))

# get only 7 ones
df_filt7 <- df_filt78 %>% filter(Timepoints == 7)
df_filt7 %>% select(Peptide_id) %>% unique() %>% dim() # 356 peptides for peptides in 7 timepoints
df_filt7$Depth <- factor(df_filt7$Depth, levels = c('SRF','DCL','BDCL'))

```

Now I do it differently: just + and - the standard error.
This is how I used to derive the error bar before (https://faculty.washington.edu/stuve/log_error.pdf)
log scale error bar: d(log2y)=1/log2 * (dy / y)
df_ave_rep2 <- df_ave_rep %>% mutate(ave_abundance_ratio = 2^Ave_abundance_ratio) %>% mutate(rel_error = sd_abundance_ratio/ave_abundance_ratio) %>% mutate(log2_sd_abundance_ratio = (1/log(2))*rel_error) %>% mutate(error_up=Ave_abundance_ratio+log2_sd_abundance_ratio) %>% mutate(error_down=Ave_abundance_ratio-log2_sd_abundance_ratio)

Plot for peptides present in 7 or 8 timepoints
```{r}

# (4) Plot the scatter plot with error bars
theme_set(theme_bw())

ggplot(df_filt78, aes(x=elapsed_hours,y=Ave_abundance_ratio, color=Depth, group=interaction(Peptide_id,Depth))) +
  geom_point(size=2, shape=21) +
  geom_line()+
  geom_errorbar(aes(ymin=error_down, ymax=error_up), width=.2, position=position_dodge(.9))+
  scale_color_manual(values=cols) +
  ylab("Mean protein abundance ratio (log2(16O/18O)) \n") +
  xlab("\n Time of day on June 26-27 2019 (Daylight 05:17-20:30)") +
  scale_x_continuous(breaks=df_time$elapsed_hours,labels =c(df_time$date_time))+
  ggtitle("Time series abundance_ratio of peptide_id \n")+
  ## adjust positions
  theme(plot.title = element_text(size = 20,hjust = 0.5, family="serif")) + 
  theme(axis.title.x = element_text(size = 15,hjust = 0.5, family="serif")) + 
  theme(axis.title.y = element_text(size = 15,hjust = 0.5, family="serif")) + 
  theme(axis.text.x = element_text(hjust = 0.9, vjust=0.9,angle=40,size=13, family="serif"))+
  theme(axis.text.y = element_text(size=10)) +
  annotate("rect", xmin = 7.75, xmax = 16.53, ymin = -Inf, ymax = Inf, alpha = .2)
  # geom_rect(aes(xmin=7.75, xmax=16.53, ymin=0, ymax=Inf))
  # theme(panel.grid.major = element_blank()) +
  # theme(panel.grid.minor = element_blank())
```

without error bars
```{r}
theme_set(theme_bw())
ggplot(df_filt78, aes(x=elapsed_hours,y=Ave_abundance_ratio, color=Depth, group=interaction(Peptide_id,Depth))) +
  geom_point(size=2, shape=21) +
  geom_line()+
  # geom_errorbar(aes(ymin=error_down, ymax=error_up), width=.2, position=position_dodge(.9))+
  scale_color_manual(values=cols) +
  ylab("Mean protein abundance ratio (log2(16O/18O)) \n") +
  xlab("\n Time of day on June 26-27 2019 (Daylight 05:17-20:30)") +
  scale_x_continuous(breaks=df_time$elapsed_hours,labels =c(df_time$date_time))+
  ggtitle("Time series abundance_ratio of peptide_id \n")+
  ## adjust positions
  theme(plot.title = element_text(size = 20,hjust = 0.5, family="serif")) + 
  theme(axis.title.x = element_text(size = 15,hjust = 0.5, family="serif")) + 
  theme(axis.title.y = element_text(size = 15,hjust = 0.5, family="serif")) + 
  theme(axis.text.x = element_text(hjust = 0.9, vjust=0.9,angle=40,size=13, family="serif"))+
  theme(axis.text.y = element_text(size=10)) +
  annotate("rect", xmin = 7.75, xmax = 16.53, ymin = -Inf, ymax = Inf, alpha = .2)
```


### 4.1. Surface(SRF)

```{r}
# color code
# 1. Surface(orange): #fc8d62
# 2. DCL(green): #66c2a5
# 3. BDCL(blue): #8da0cb
color_vec <- c('#fc8d62','#66c2a5','#8da0cb')
depth_vec <- c('SRF','DCL','BDCL')

time_series_1depth_woError <- function(df_filt78, depth){
  theme_set(theme_bw())
  # filter depth
  df_filt78_s <- df_filt78 %>% filter(Depth == depth_vec[depth])
  ggplot(df_filt78_s, aes(x=elapsed_hours,y=Ave_abundance_ratio, group=Peptide_id)) +
    geom_point(size=2, shape=21, color=color_vec[depth]) +
    geom_line(color= color_vec[depth])+
    ylab("Mean protein abundance ratio (log2(16O/18O)) \n") +
    xlab("\n Time of day on June 26-27 2019 (Daylight 05:17-20:30)") +
    scale_x_continuous(breaks=df_time$elapsed_hours,labels =c(df_time$date_time))+
    ggtitle(paste0("Time series abundance_ratio of peptide_id"," (",depth_vec[depth],")","\n"))+
    ## adjust positions
    theme(plot.title = element_text(size = 20,hjust = 0.5, family="serif")) + 
    theme(axis.title.x = element_text(size = 15,hjust = 0.5, family="serif")) + 
    theme(axis.title.y = element_text(size = 15,hjust = 0.5, family="serif")) + 
    theme(axis.text.x = element_text(hjust = 0.9, vjust=0.9,angle=40,size=13, family="serif"))+
    theme(axis.text.y = element_text(size=10)) +
    annotate("rect", xmin = 7.75, xmax = 16.53, ymin = -Inf, ymax = Inf, alpha = .2)
    # theme(panel.grid.major = element_blank()) +
    # theme(panel.grid.minor = element_blank())
}

time_series_1depth_wError <- function(df_filt78, depth){
  theme_set(theme_bw())
  # filter depth
  df_filt78_s <- df_filt78 %>% filter(Depth == depth_vec[depth])
  ggplot(df_filt78_s, aes(x=elapsed_hours,y=Ave_abundance_ratio, group=Peptide_id)) +
    geom_point(size=2, shape=21, color=color_vec[depth]) +
    geom_line(color= color_vec[depth])+
    geom_errorbar(aes(ymin=error_down, ymax=error_up), width=.05, position=position_dodge(.2),color='red')+
    ylab("Mean protein abundance ratio (log2(16O/18O)) \n") +
    xlab("\n Time of day on June 26-27 2019 (Daylight 05:17-20:30)") +
    scale_x_continuous(breaks=df_time$elapsed_hours,labels =c(df_time$date_time))+
    ggtitle(paste0("Time series abundance_ratio of peptide_id"," (",depth_vec[depth],")","\n"))+
    ## adjust positions
    theme(plot.title = element_text(size = 20,hjust = 0.5, family="serif")) + 
    theme(axis.title.x = element_text(size = 15,hjust = 0.5, family="serif")) + 
    theme(axis.title.y = element_text(size = 15,hjust = 0.5, family="serif")) + 
    theme(axis.text.x = element_text(hjust = 0.9, vjust=0.9,angle=40,size=13, family="serif"))+
    theme(axis.text.y = element_text(size=10)) +
    annotate("rect", xmin = 7.75, xmax = 16.53, ymin = -Inf, ymax = Inf, alpha = .2)
    # theme(panel.grid.major = element_blank()) +
    # theme(panel.grid.minor = element_blank())
}

# when we use all 7, 8 appearance cases
time_series_1depth_woError(df_filt78,1)
time_series_1depth_wError(df_filt78,1)

# when we use only 8 appearance cases
time_series_1depth_woError(df_filt8,1)
time_series_1depth_wError(df_filt8,1)

# when we use only 7 appearance cases
time_series_1depth_woError(df_filt7,1)
time_series_1depth_wError(df_filt7,1)

```

### 4.2. Deep Chlorophyll layer (DCL)

```{r}
# when we use all 7, 8 appearance cases
time_series_1depth_woError(df_filt78,2)
time_series_1depth_wError(df_filt78,2)

# when we use only 8 appearance cases
time_series_1depth_woError(df_filt8,2)
time_series_1depth_wError(df_filt8,2)

# when we use only 7 appearance cases
time_series_1depth_woError(df_filt7,2)
time_series_1depth_wError(df_filt7,2)

```

### 4.3. Below Deep Chlorophyll layer (BDCL)

```{r}
# when we use all 7, 8 appearance cases
time_series_1depth_woError(df_filt78,3)
time_series_1depth_wError(df_filt78,3)

# when we use only 8 appearance cases
time_series_1depth_woError(df_filt8,3)
time_series_1depth_wError(df_filt8,3)

# when we use only 7 appearance cases
time_series_1depth_woError(df_filt7,3)
time_series_1depth_wError(df_filt7,3)

```

### 5. Time series clustering

For time series clustering with R, the first step is to work out an appropriate distance/similarity metric, and then, at the second step, use existing clustering techniques, such as k-means, hierarchical clustering, density-based clustering or subspace clustering, to find clustering structures.
(http://www.rdatamining.com/examples/time-series-clustering-classification)

### 5.1. Hierarchical clustering using Dynamic time warping distance
Dynamic Time Warping (DTW) finds optimal alignment between two time series, and DTW distance is used as a distance metric in the example below.
(http://www.rdatamining.com/examples/time-series-clustering-classification)

```{r}

# let's try cluster our time series data
colnames(df_filt8)
df_8 <- df_filt8 %>% filter(Depth=='SRF') %>% select(Peptide_id,Time,Ave_abundance_ratio)

# reshape the dataframe with timepoints
library(maditr)
v_names <- c("T1","T2","T3","T4","T5","T6","T7","T8")
df_8$Time <- factor(df_8$Time, levels=v_names)
dc_8 <- dcast(df_8, Peptide_id ~ Time, value.var = "Ave_abundance_ratio")
# make Peptide_id more simpler (Pep_1 -> 1)
dc_8$Peptide_id <- str_replace(dc_8$Peptide_id,"Pep_","P.")
# make first column into row name
dc_8 <- tibble::column_to_rownames(dc_8, var="Peptide_id")

# DTW distances
library(dtw)
any(is.na(dc_8)) # False: there is no NA in the table
distMatrix <- dist(dc_8, method="DTW")
hc <- hclust(distMatrix, method="average")
plot(hc, cex=0.7, xlab='Hierarchical clustering of Distance(DTW) Matrix')

```


Draw the particular small cluster in the time series plot

```{r}
# function for plotting cluster of piptides
time_series_clust_wError <- function(df_filt78, depth, clust1){
  theme_set(theme_bw())
  # filter depth
  df_filt78_s <- df_filt78 %>% filter(Depth == depth_vec[depth]) %>% filter(Peptide_id %in% clust1)
  ggplot(df_filt78_s, aes(x=elapsed_hours,y=Ave_abundance_ratio, group=Peptide_id)) +
    geom_point(size=2, shape=21, color=color_vec[depth]) +
    geom_line(color= color_vec[depth])+
    geom_errorbar(aes(ymin=error_down, ymax=error_up), width=.05, position=position_dodge(.2),color='red')+
    ylab("Mean protein abundance ratio (log2(16O/18O)) \n") +
    xlab("\n Time of day on June 26-27 2019 (Daylight 05:17-20:30)") +
    scale_x_continuous(breaks=df_time$elapsed_hours,labels =c(df_time$date_time))+
    ggtitle(paste0("Time series abundance_ratio of peptide_id"," (",depth_vec[depth],")","\n"))+
    ## adjust positions
    theme(plot.title = element_text(size = 20,hjust = 0.5, family="serif")) + 
    theme(axis.title.x = element_text(size = 15,hjust = 0.5, family="serif")) + 
    theme(axis.title.y = element_text(size = 15,hjust = 0.5, family="serif")) + 
    theme(axis.text.x = element_text(hjust = 0.9, vjust=0.9,angle=40,size=13, family="serif"))+
    theme(axis.text.y = element_text(size=10)) +
    annotate("rect", xmin = 7.75, xmax = 16.53, ymin = -Inf, ymax = Inf, alpha = .2)
    # theme(panel.grid.major = element_blank()) +
    # theme(panel.grid.minor = element_blank())
}

# cluster1 (outgroup-like)
clust1 <- c('632',"596","443","453","522","153","851","493","50","574","584","402","813")
clust1 <- str_replace(clust1,"^","Pep_") # make Peptide_id
time_series_clust_wError(df_filt8, 1, clust1)

# cluster2
clust2 <- c("197","78","562","112","87","310","207", "47","319","91","289","82","697","441","142","191", "34","105","426","882","8","18","5","132","327")
clust2 <- str_replace(clust2,"^","Pep_") # make Peptide_id
time_series_clust_wError(df_filt8, 1, clust2)

```


### 5.2. Principal coordinate analysis (ordination plot, PCoA) with DTW distance
Use the DTW distance matrix to plot PCoA

```{r}
# Use the 
# Transform distMatrix into matrix A
distmat <- as(distMatrix, "matrix")
dim(distmat)
A <- -1/2*distmat^2
dim(A)
# Scaling/centering of Matrix A
RowM <- rowMeans(A)
ColM <- colMeans(A)
M <- mean(A)
Delta <- A
for (i in 1:dim(A)[1]){
        for (j in 1:dim(A)[2]) {
                Delta[i,j] <- Delta[i,j] - RowM[i] - ColM[j] + M
        }
}

# Compute the eigenvalues and eigenvectors of Delta
Eigen <- eigen(Delta)
# SEE YOU GET 5 EIGENVALUES (nrow = ncol of sqare distance matrix)
# Scale the eigenvectors
FirstEigenvector <- Eigen$vectors[,1]
FirstEigenvalue <- Eigen$values[1]
SecondEigenvector <- Eigen$vectors[,2]
SecondEigenvalue <- Eigen$values[2]

PrincipalCoords <- data.frame(First = FirstEigenvector*sqrt(FirstEigenvalue),
                              Sedond = SecondEigenvector * sqrt(SecondEigenvalue))

# we can take a shortcut instead: cmdScale or pco is now equal your PrincipalCoords (https://rstudio-pubs-static.s3.amazonaws.com/68544_06343669257d4f35aaca449f9ff1e6f7.html, https://genomicsclass.github.io/book/pages/mds.html)
require(labdsv)
pco_pep <- pco(distmat, k =2)
# pco_pep2 <- cmdscale(distmat, k =2)
# cmdscale(distmat, 2, eig=TRUE)$GOF

# plot PCoA without peptide_id labels
ggplot(as.data.frame(pco_pep$points), aes(x = V1, y = V2, label = row.names(as.data.frame(pco_pep$points)))) + 
  theme(plot.title = element_text(size = 20,hjust = 0.5, face="bold")) +
  geom_point(size = 4, color='pink',alpha=0.7)+
  xlab(paste0('\n PCoA1', " (explained variance: ",round(pco_pep$GOF[1],3)*100,"%)"))+
  ylab(paste0("PCoA2"," (explained variance: ",round(pco_pep$GOF[2]-pco_pep$GOF[1],3)*100,"%) \n")) +
  ggtitle("Peptide ordination PCoA plot (DTW distance) \n") +
  ## adjust positions
  guides(fill = guide_legend(ncol = 4,reverse = T))+
  theme(legend.position="bottom") +
  theme(plot.title = element_text(size = 20,hjust = 0.5, face='bold')) + 
  theme(axis.title.x = element_text(size = 15,hjust = 0.5, face='bold')) + 
  theme(axis.title.y = element_text(size = 13,hjust = 0.5, face='bold')) + 
  theme(axis.text.x = element_text(angle = 90, hjust = 0.95,face='bold', vjust=0.4,size=15))+
  theme(axis.text.y = element_text(size=15, face='bold'))

# plot PCoA with peptide_id labels
library(ggrepel)
PCoA_1 <- ggplot(as.data.frame(pco_pep$points), aes(x = V1, y = V2, label = row.names(as.data.frame(pco_pep$points)))) + 
  theme(plot.title = element_text(size = 20,hjust = 0.5, face="bold")) +
  geom_point(size = 4, color='pink',alpha=0.7)+
  xlab(paste0('\n PCoA1', " (explained variance: ",round(pco_pep$GOF[1],3)*100,"%)"))+
  ylab(paste0("PCoA2"," (explained variance: ",round(pco_pep$GOF[2]-pco_pep$GOF[1],3)*100,"%) \n")) +
  ggtitle("Peptide ordination PCoA plot (DTW distance) \n") +
  ## adjust positions
  guides(fill = guide_legend(ncol = 4,reverse = T))+
  theme(legend.position="bottom") +
  theme(plot.title = element_text(size = 20,hjust = 0.5, face='bold')) + 
  theme(axis.title.x = element_text(size = 15,hjust = 0.5, face='bold')) + 
  theme(axis.title.y = element_text(size = 15,hjust = 0.5, face='bold')) + 
  theme(axis.text.x = element_text(angle = 90, hjust = 0.95,face='bold', vjust=0.4,size=15))+
  theme(axis.text.y = element_text(size=15, face='bold')) +
  ggrepel::geom_label_repel()
  # theme(panel.grid.major = element_blank()) +
  # theme(panel.grid.minor = element_blank(), panel.background=element_blank(), plot.background=element_blank())

PCoA_1

```

### 5.2.2. Ordination analysis by samples (PCA, Principal component analysis)

```{r}
# make the matrix by reshaping dataframe
library(maditr)
dc_ave <- dcast(df_ave, SampleID ~ Peptide_id, value.var = "Mean_abundance_ratio")
dim(dc_ave)
# names(dc_ave)
rownames(dc_ave)
# make Peptide_id more simpler (Pep_1 -> P.1)
names(dc_ave) <- str_replace(names(dc_ave),"Pep_","P.")
# make first column into row name
dc_ave <- tibble::column_to_rownames(dc_ave, var="SampleID")

dim(dc_ave) # 67 samples (row) x 3366 peptides (columns)

# First, the typical principal component analysis on the samples would be to transpose the data such that the samples are rows of the data matrix. The prcomp function can be used to return the principal components and other variables.(https://genomicsclass.github.io/book/pages/pca_svd.html)

# pc <- prcomp(dc_ave) # due to NA this is not working

# how should we change NA in the matrix?
any(is.na(dc_ave))
sum(is.na(dc_ave)) 

# let's replace na into minimum value for each sample
dc_namin <- dc_ave
for (i in 1:dim(dc_ave)[1]){
  rowMin <- (min(dc_ave[i,] ,na.rm=T))
  for (j in 1:dim(dc_ave)[2]) {
    if (is.na(dc_namin[i,j])){
      dc_namin[i,j] <- rowMin
      # print(dc_namin[i,j])
    }
  }
}

sum(is.na(dc_namin)) # 0 mean success

# PCA with prcomp
pc <- prcomp(dc_namin)
eigs <- pc$sdev^2
# variance explained
eigs[1] / sum(eigs) # pc1
eigs[2] / sum(eigs) # pc2

# First, a new dataframe should be created, with the information of sample-group. (http://huboqiang.cn/2016/03/03/RscatterPlotPCA)
df_out <- as.data.frame(pc$x)
df_out$depth <- sapply( strsplit(as.character(row.names(df_out)), "_"), "[[", 1 )
df_out$time <- sapply( strsplit(as.character(row.names(df_out)), "_"), "[[", 2 )
df_out$time <- as.numeric(str_replace(df_out$time, "T",""))
df_out$time <- factor(df_out$time,levels=1L:8L)
df_out$rep <- sapply( strsplit(as.character(row.names(df_out)), "_"), "[[", 3 )
df_out$depth <- factor(df_out$depth, levels=depth_vec)

head(df_out)

# plot PCA with timepoint labels
ggplot(df_out,aes(x=PC1,y=PC2,label = time))+
  theme(plot.title = element_text(size = 20,hjust = 0.5, face="bold")) +
  geom_point(size = 5, alpha=0.9, aes(col= depth))+
  scale_fill_manual(values=cols) +
  xlab(paste0('\n PC1', " (explained variance: ",round(eigs[1] / sum(eigs),3)*100,"%)"))+
  ylab(paste0("PC2"," (explained variance: ",round(eigs[2] / sum(eigs),3)*100,"%) \n")) +
  ggtitle("Principle component analysis plot for samples \n") +
  ## adjust positions
  guides(fill = guide_legend(ncol = 4,reverse = T))+
  theme(legend.position="bottom") +
  theme(plot.title = element_text(size = 20,hjust = 0.5, face='bold')) + 
  theme(axis.title.x = element_text(size = 15,hjust = 0.5, face='bold')) + 
  theme(axis.title.y = element_text(size = 15,hjust = 0.5, face='bold')) + 
  theme(axis.text.x = element_text(angle = 90, hjust = 0.95,face='bold', vjust=0.4,size=15))+
  theme(axis.text.y = element_text(size=15, face='bold'))


# plot PCA with timepoint labels
ggplot(df_out,aes(x=PC1,y=PC2,label = time))+
  theme(plot.title = element_text(size = 20,hjust = 0.5, face="bold")) +
  geom_point(size = 4.5, alpha=0.9, aes(col= depth))+
  scale_fill_manual(values=cols) +
  xlab(paste0('\n PC1', " (explained variance: ",round(eigs[1] / sum(eigs),3)*100,"%)"))+
  ylab(paste0("PC2"," (explained variance: ",round(eigs[2] / sum(eigs),3)*100,"%) \n")) +
  ggtitle("Principle component analysis plot for samples \n") +
  ## adjust positions
  guides(fill = guide_legend(ncol = 4,reverse = T))+
  theme(legend.position="bottom") +
  theme(plot.title = element_text(size = 20,hjust = 0.5, face='bold')) + 
  theme(axis.title.x = element_text(size = 15,hjust = 0.5, face='bold')) + 
  theme(axis.title.y = element_text(size = 15,hjust = 0.5, face='bold')) + 
  theme(axis.text.x = element_text(angle = 90, hjust = 0.95,face='bold', vjust=0.4,size=15))+
  theme(axis.text.y = element_text(size=15, face='bold'))+
  ggrepel::geom_label_repel()

# plot PCA with timepoint gradient

ggplot(df_out,aes(x=PC1,y=PC2,alpha = time))+
  theme(plot.title = element_text(size = 20,hjust = 0.5, face="bold")) +
  geom_point(size = 5, stroke=1.2, aes(col=depth))+
  # geom_point(size = 5,stroke = 1.3, shape=21, aes(fill=depth))+
  scale_fill_manual(values=cols) +
  scale_alpha_manual(values=seq(0.3,1,length.out = 8)) +
  xlab(paste0('\n PC1', " (explained variance: ",round(eigs[1] / sum(eigs),3)*100,"%)"))+
  ylab(paste0("PC2"," (explained variance: ",round(eigs[2] / sum(eigs),3)*100,"%) \n")) +
  ggtitle("Principle component analysis plot for samples \n") +
  ## adjust positions
  guides(fill = guide_legend(ncol = 4,reverse = T))+
  theme(legend.position="bottom") +
  theme(plot.title = element_text(size = 20,hjust = 0.5, face='bold')) + 
  theme(axis.title.x = element_text(size = 15,hjust = 0.5, face='bold')) + 
  theme(axis.title.y = element_text(size = 15,hjust = 0.5, face='bold')) + 
  theme(axis.text.x = element_text(angle = 90, hjust = 0.95,face='bold', vjust=0.4,size=15))+
  theme(axis.text.y = element_text(size=15, face='bold'))
  # ggrepel::geom_label_repel()


PCoA_1 <- ggplot(as.data.frame(pco_pep$points), aes(x = V1, y = V2, label = row.names(as.data.frame(pco_pep$points)))) + 
  theme(plot.title = element_text(size = 20,hjust = 0.5, face="bold")) +
  geom_point(size = 4, color='pink',alpha=0.7)+
  xlab(paste0('\n PCoA1', " (explained variance: ",round(pco_pep$GOF[1],3)*100,"%)"))+
  ylab(paste0("PCoA2"," (explained variance: ",round(pco_pep$GOF[2]-pco_pep$GOF[1],3)*100,"%) \n")) +
  ggtitle("Peptide ordination PCoA plot (DTW distance) \n") +
  ## adjust positions
  guides(fill = guide_legend(ncol = 4,reverse = T))+
  theme(legend.position="bottom") +
  theme(plot.title = element_text(size = 20,hjust = 0.5, face='bold')) + 
  theme(axis.title.x = element_text(size = 15,hjust = 0.5, face='bold')) + 
  theme(axis.title.y = element_text(size = 15,hjust = 0.5, face='bold')) + 
  theme(axis.text.x = element_text(angle = 90, hjust = 0.95,face='bold', vjust=0.4,size=15))+
  theme(axis.text.y = element_text(size=15, face='bold')) +
  ggrepel::geom_label_repel()
  # theme(panel.grid.major = element_blank()) +
  # theme(panel.grid.minor = element_blank(), panel.background=element_blank(), plot.background=element_blank())

PCoA_1




# PCA with sparse pca methods

library(sparsepca)
# Sparse Principal Component Analysis (spca).
spc <- spca(dc_namin, k = 2, alpha = 1e-04, beta = 1e-04, center = TRUE,
            scale = FALSE, max_iter = 1000, tol = 1e-05, verbose = 0)
summary(spc)
# Randomized Sparse Principal Component Analysis (rspca).
rspc <- rspca(dc_namin, k = 2, alpha = 1e-04, beta = 1e-04, center = TRUE,
              scale = FALSE, max_iter = 1000, tol = 1e-05, verbose = 0)
summary(rspc)
# Robust Sparse Principal Component Analysis (robspca)
robspc <- robspca(dc_namin, k = 2, alpha = 1e-04, beta = 1e-04, gamma = 100,
                  center = TRUE, scale = FALSE, max_iter = 1000, tol = 1e-05, verbose = 0)
summary(robspc)


sparse_pca_plot <- function(spc,type="Sparse"){
  df_spc <- data.frame(summary(spc))
  # variance explained
  df_spc[3,1] # pc1
  df_spc[3,2] # pc2

  df_out <- as.data.frame(spc$scores)
  colnames(df_out) <- c("PC1","PC2")
  df_out$depth <- sapply( strsplit(as.character(row.names(df_out)), "_"), "[[", 1 )
  df_out$time <- sapply( strsplit(as.character(row.names(df_out)), "_"), "[[", 2 )
  df_out$rep <- sapply( strsplit(as.character(row.names(df_out)), "_"), "[[", 3 )
  df_out$depth <- factor(df_out$depth, levels=depth_vec)
  
  head(df_out)
  
  ggplot(df_out,aes(x=PC1,y=PC2,color=depth))+
    theme(plot.title = element_text(size = 20,hjust = 0.5, face="bold")) +
    geom_point(size = 4,alpha=0.7)+
    scale_fill_manual(values=cols) +
    xlab(paste0('\n PC1', " (explained variance: ",round(df_spc[3,1],3)*100,"%)"))+
    ylab(paste0("PC2"," (explained variance: ",round(df_spc[3,2],3)*100,"%) \n")) +
    ggtitle(paste0(type," principle component analysis plot for samples \n")) +
    ## adjust positions
    guides(fill = guide_legend(ncol = 4,reverse = T))+
    theme(legend.position="bottom") +
    theme(plot.title = element_text(size = 20,hjust = 0.5, face='bold')) + 
    theme(axis.title.x = element_text(size = 15,hjust = 0.5, face='bold')) + 
    theme(axis.title.y = element_text(size = 15,hjust = 0.5, face='bold')) + 
    theme(axis.text.x = element_text(angle = 90, hjust = 0.95,face='bold', vjust=0.4,size=15))+
    theme(axis.text.y = element_text(size=15, face='bold'))
    # theme(panel.grid.major = element_blank()) +
    # theme(panel.grid.minor = element_blank(), panel.background=element_blank(), plot.background=element_blank())
}

sparse_pca_plot(spc,type="Sparse")
sparse_pca_plot(rspc,type="Randomized Sparse")
sparse_pca_plot(robspc,type="Robust Sparse")

```


### 5.3. Unsupervised clustering with various distances (SBD, DTW, ...) / prototyping methods / clustering methods \
- Using dtwclust package
- How many clusters should we use? Evaluate by CVI (Cluster validity index, the bigger the better for internal CVI) \
- Please normalize before clustering

#### (0) Data formating for tsclust input 

```{r}
# (1) Change our data into list format for input into tsclust
colnames(df_filt8)

make_list <- function(df_filt8,depth){
  df_SRF8 <- df_filt8 %>% filter(Depth==depth) %>% select(Peptide_id,Time,Ave_abundance_ratio)
  # reshape the dataframe with timepoints
  library(maditr)
  v_names <- c("T1","T2","T3","T4","T5","T6","T7","T8")
  df_SRF8$Time <- factor(df_SRF8$Time, levels=v_names)
  dc_SRF8 <- dcast(df_SRF8, Peptide_id ~ Time, value.var = "Ave_abundance_ratio")
  # make Peptide_id more simpler (Pep_1 -> P.1)
  dc_SRF8$Peptide_id <- str_replace(dc_SRF8$Peptide_id,"Pep_","P.")
  # make first column into row name
  dc_SRF8 <- tibble::column_to_rownames(dc_SRF8, var="Peptide_id")
  # make it into list format
  # l_SRF8 <- setNames(split(dc_SRF8, seq(nrow(dc_SRF8))), rownames(dc_SRF8))
  l_SRF8 <- as.list(as.data.frame(t(dc_SRF8)))
  return(l_SRF8)
}

l_SRF8 <- make_list(df_filt8,'SRF')
l_DCL8 <- make_list(df_filt8,'DCL')
l_BDCL8 <- make_list(df_filt8,'BDCL')

```

#### (1) Hierarchical clustering w/ shape based distance

```{r}
# input into tsclust
library(dtwclust)
require("TSclust")

### Hierarchical clustering w/ shape based distance
hc_sbd <- tsclust(l_SRF8, type = "h", k = 2L:10L,
  preproc = zscore, seed = 899,
  distance = "sbd", centroid = shape_extraction,
  control = hierarchical_control(method = "average"))

internal_CVI <- function(hc_sbd,main){
  names(hc_sbd) <- 2L:10L
  (eval <- sapply(hc_sbd, cvi, type = "internal"))
  # divide CH value with 100 just to plot with other internal CVIs 
  eval['CH',] <- eval['CH',]/100
  t(eval)
  matplot(x=seq(2,10,by=1),y=t(eval), type = c("b"),pch=1,col = 1:7,
          xlab="Number of clusters",ylab="Internal CVI (cluster validity index)",main=main,axes=F) #plot
  axis(2)
  axis(side=1,at=2:10)
  legend("bottomright", legend = c("Sil","SF","CH/100","DB","DBstar","D","COP"), col=1:7, pch=1,cex=0.8) # optional legend
}

internal_CVI(hc_sbd,"Hierarchical clustering w/ shape based distance")

# use 3 or 4 clusters
hc_sbd3 <- tsclust(l_SRF8, type = "h", k = 3L,
  distance = "sbd", centroid = shape_extraction,
  control = hierarchical_control(method = "average"))

hc_sbd4 <- tsclust(l_SRF8, type = "h", k = 4L,
  distance = "sbd", centroid = shape_extraction,
  control = hierarchical_control(method = "average"))

# cluster dendrogram
plot(hc_sbd3)
# The series and the obtained prototypes can be plotted too
plot(hc_sbd3, type = "sc")
# Focusing on the first cluster
plot(hc_sbd3, type = "series", clus = 1L)
plot(hc_sbd3, type = "centroids", clus = 1L)

# cluster dendrogram
plot(hc_sbd4)
# The series and the obtained prototypes can be plotted too
plot(hc_sbd4, type = "sc")
```

#### (2-1) partial clustering methods - DTW

```{r}
### partial clustering methods
# z-normalization
l_SRF8_z <- zscore(l_SRF8)

# DTW distance
pc_dtw <- tsclust(l_SRF8_z, k = 2L:10L,
  distance = "dtw_basic", centroid = "dba",
  trace = TRUE, seed = 8,
  norm = "L2", window.size = 8L,
  args = tsclust_args(cent = list(trace = TRUE)))

internal_CVI(pc_dtw, "Partial clustering with DTW distance")

# use 4, 5, 7 clusters
pc_dtw4 <- tsclust(l_SRF8_z, k = 4L,
  distance = "dtw_basic", centroid = "dba",
  trace = TRUE, seed = 8,
  norm = "L2", window.size = 8L,
  args = tsclust_args(cent = list(trace = TRUE)))
pc_dtw5 <- tsclust(l_SRF8_z, k = 5L,
  distance = "dtw_basic", centroid = "dba",
  trace = TRUE, seed = 8,
  norm = "L2", window.size = 8L,
  args = tsclust_args(cent = list(trace = TRUE)))
pc_dtw7 <- tsclust(l_SRF8_z, k = 7L,
  distance = "dtw_basic", centroid = "dba",
  trace = TRUE, seed = 8,
  norm = "L2", window.size = 8L,
  args = tsclust_args(cent = list(trace = TRUE)))

# Prototypes for 4 clusters
plot(pc_dtw4)

# Prototypes for 5 clusters
plot(pc_dtw5)

# Prototypes for 7 clusters
plot(pc_dtw7)

```

#### (2-2) partial clustering methods - DTW_lb
cross-distance matrix is NOT symmetric, which can be problematic for

```{r}
# DTW_lb distance method
pc_dtwlb <- tsclust(l_SRF8_z, k = 2L:10L,
  distance = "dtw_lb", centroid = "dba",
  trace = TRUE, seed = 8,
  norm = "L2", window.size = 4L,
  control = partitional_control(pam.precompute = FALSE),
  args = tsclust_args(cent = list(trace = TRUE)))

internal_CVI(pc_dtwlb, "Partial clustering with DTW_lb distance")

# use 8 clusters
pc_dtwlb8 <- tsclust(l_SRF8_z, k = 8L,
  distance = "dtw_lb", centroid = "dba",
  trace = TRUE, seed = 8,
  norm = "L2", window.size = 4L,
  control = partitional_control(pam.precompute = FALSE),
  args = tsclust_args(cent = list(trace = TRUE)))

# Prototypes for 8 clusters
plot(pc_dtwlb8)

```

#### (2-3) partial clustering methods - k-shape

```{r}
# k-shape method
pc_ks <- tsclust(l_SRF8_z, k = 2L:10L,
  distance = "sbd", centroid = "shape",
  seed = 8, trace = TRUE)

internal_CVI(pc_ks, "Partial clustering with k-shape method")

# use 3 or 4 clusters
pc_ks3 <- tsclust(l_SRF8_z, k = 3L,
  distance = "sbd", centroid = "shape",
  seed = 8, trace = TRUE)

pc_ks4 <- tsclust(l_SRF8_z, k = 4L,
  distance = "sbd", centroid = "shape",
  seed = 8, trace = TRUE)

pc_ks5 <- tsclust(l_SRF8_z, k = 5L,
  distance = "sbd", centroid = "shape",
  seed = 8, trace = TRUE)

# Prototypes for 3 clusters
plot(pc_ks3)

# Prototypes for 4 clusters
plot(pc_ks4)

# Prototypes for 5 clusters
plot(pc_ks5)
```


#### (2-4) partial clustering methods - Tadpole 
problematic for our dataset (series' cross-distance matrix is NOT symmetric)

```{r}
# Tadpole method
pc_tp <- tsclust(l_SRF8_z, k = 2L:10L, type = "t",
  seed = 8, trace = TRUE,
  control = tadpole_control(dc = 1.5,
  window.size = 4L))

internal_CVI(pc_tp, "Partial clustering with Tadpole method")

# use 8 clusters
pc_tp8 <- tsclust(l_SRF8_z, k = 8L, type = "t",
  seed = 8, trace = TRUE,
  control = tadpole_control(dc = 1.5,
  window.size = 4L))

# Prototypes for 8 clusters
plot(pc_tp8)

```

### 6. RAIN analysis (Rhythmicity Analysis Incorporating Non-parametric methods)

### 6.1. Checking the abundance_ratio distribution of peptides in each sample

(1) Peptide level histograms

```{r}
# function to plot histogram
hist_abundance_ratio <- function(depth="SRF",time="T1"){
  df_ave_SRF_T1 <- df_ave %>% filter(Time==time & Depth ==depth)
  theme_set(theme_bw())
  h1 <- ggplot(df_ave_SRF_T1, aes(x=Mean_abundance_ratio)) +
    geom_freqpoly(binwidth = 0.05, aes(color=Replicate)) +
    scale_fill_brewer(palette=' Set2') +
    ylab("Mean protein abundance ratio (log2(16O/18O)) \n") +
    xlab("\n Frequency of ratio") +
    ggtitle(paste0("Histogram of sample (",depth,"-",time,") \n"))+
    ## adjust positions
    theme(plot.title = element_text(size = 20,hjust = 0.5, family="serif")) + 
    theme(axis.title.x = element_text(size = 15,hjust = 0.5, family="serif")) + 
    theme(axis.title.y = element_text(size = 15,hjust = 0.5, family="serif")) + 
    theme(axis.text.x = element_text(angle = 90, hjust = 0.5, vjust=0.3,size=13, family="serif"))+
    theme(axis.text.y = element_text(size=10))
    # theme(panel.grid.major = element_blank())
    # theme(panel.grid.minor = element_blank()) 
  return(h1)
}

hist_abundance_ratio(depth="SRF",time="T1")
hist_abundance_ratio(depth="SRF",time="T2")
hist_abundance_ratio(depth="SRF",time="T3")
hist_abundance_ratio(depth="SRF",time="T4")
hist_abundance_ratio(depth="SRF",time="T5")
hist_abundance_ratio(depth="SRF",time="T6")
hist_abundance_ratio(depth="SRF",time="T7")
hist_abundance_ratio(depth="SRF",time="T8")

# draw histogram in multigrids
library(gridExtra)
paste0("T",1L:8L)

l <- list()
for (i in paste0("T",1L:8L)){
  print(i)
  l[[i]] <- hist_abundance_ratio(depth="SRF",time=i)
}
length(l)

grid.arrange(grobs = l, ncol=3)

```

(2) Spectra level histograms

```{r}
# function to plot histogram
hist_abundance_ratio_spec <- function(depth="SRF",time="T1"){
  df_int_SRF_T1 <- df_int %>% filter(Time==time & Depth ==depth) %>% select(-Peptide_id)
  theme_set(theme_bw())
  h1 <- ggplot(df_int_SRF_T1, aes(x=cent.log2.16O.18O.Ratio)) +
    geom_freqpoly(binwidth = 0.05, aes(color=Replicate)) +
    scale_fill_brewer(palette='Set2') +
    ylab("Centered log2(16O/18O) ratio \n") +
    xlab("\n Frequency of ratio (Spec-level)") +
    ggtitle(paste0("Histogram of sample (",depth,"-",time,") \n"))+
    ## adjust positions
    theme(plot.title = element_text(size = 20,hjust = 0.5, family="serif")) + 
    theme(axis.title.x = element_text(size = 15,hjust = 0.5, family="serif")) + 
    theme(axis.title.y = element_text(size = 15,hjust = 0.5, family="serif")) + 
    theme(axis.text.x = element_text(angle = 90, hjust = 0.5, vjust=0.3,size=13, family="serif"))+
    theme(axis.text.y = element_text(size=10))
    # theme(panel.grid.major = element_blank())
    # theme(panel.grid.minor = element_blank()) 
  return(h1)
}

hist_abundance_ratio_spec(depth="SRF",time="T1")
hist_abundance_ratio_spec(depth="SRF",time="T2")
hist_abundance_ratio_spec(depth="SRF",time="T3")
hist_abundance_ratio_spec(depth="SRF",time="T4")
hist_abundance_ratio_spec(depth="SRF",time="T5")
hist_abundance_ratio_spec(depth="SRF",time="T6")
hist_abundance_ratio_spec(depth="SRF",time="T7")
hist_abundance_ratio_spec(depth="SRF",time="T8")

# draw histogram in multigrids
library(gridExtra)
paste0("T",1L:8L)

l <- list()
for (i in paste0("T",1L:8L)){
  print(i)
  l[[i]] <- hist_abundance_ratio_spec(depth="SRF",time=i)
}
length(l)

grid.arrange(grobs = l, ncol=3)

```


### 6.2. Applying rain analysis

```{r}
# setting our data into input format
df_8_S <- df_filt8 %>% filter(Depth=='SRF') %>% select(Peptide_id,Time,Ave_abundance_ratio)

# reshape the dataframe with timepoints
library(maditr)
v_names <- c("T1","T2","T3","T4","T5","T6","T7","T8")
df_8$Time <- factor(df_8$Time, levels=v_names)
dc_8 <- dcast(df_8, Peptide_id ~ Time, value.var = "Ave_abundance_ratio")
# make Peptide_id more simpler (Pep_1 -> 1)
dc_8$Peptide_id <- str_replace(dc_8$Peptide_id,"Pep_","P.")
# make first column into row name
dc_8 <- tibble::column_to_rownames(dc_8, var="Peptide_id")

t(dc_8) %>% head


# setup time vector for RAIN (source: Maria's code provided to me 3/3/21)
# The following code gives a vector where the times given in "t" are represented by a 1 in the vector "ft".
# The time series in question lasted 84 hours and sampling times were every 4 hours, so the 
# vector "ft" gives a 1 for each hour representing a sampling time, and ft could is a vector of 12 1's and deltat=4 in the RAIN call below. 
t <- c(0, 3, 6, 9, 15, 19, 22, 25)
(t <- t+1) # start from 1
# If the time series is not equally spaced it can be regularized by introducing time points with
# zero repeats. This may be combined with any of the above repeat settings.
# Example: A series measured at times {1, 3, 4, 6} is usable with the measure.sequence
# {1, 0, 1, 1, 0, 1} and a matrix x
t <- c(1,0,0,1,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1,0,0,1) # adjusted for irregular repeats

# RAIN analysis
library(rain)
rainresult <- rain(t(dc_8), period=8, measure.sequence=t, deltat=1, method='independent')

plot(-log(rainresult$pVal) ~ rainresult$phase)

# According to the original paper, adjusting p-values for multiple testing is not necessary (already done in the output): https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4266694/
# rainresult$fdr <- p.adjust(as.numeric(rainresult$pVal), method="fdr") 

# pVal cut off 0.25
dim(rainresult)
rainresult %>% filter(pVal < 0.25)
rainresult %>% filter(pVal < 0.25) %>% dim() # 69 peptides

# pVal cut off 0.15
rainresult %>% filter(pVal < 0.15)
rainresult %>% filter(pVal < 0.15) %>% dim() # 37 peptides


# rain analysis function
rain_analysis <- function(df_filt8,depth="SRF"){
  # setting our data into input format
  df_8 <- df_filt8 %>% filter(Depth==depth) %>% select(Peptide_id,Time,Ave_abundance_ratio)
  # reshape the dataframe with timepoints
  library(maditr)
  v_names <- c("T1","T2","T3","T4","T5","T6","T7","T8")
  df_8$Time <- factor(df_8$Time, levels=v_names)
  dc_8 <- dcast(df_8, Peptide_id ~ Time, value.var = "Ave_abundance_ratio")
  # make Peptide_id more simpler (Pep_1 -> 1)
  dc_8$Peptide_id <- str_replace(dc_8$Peptide_id,"Pep_","P.")
  # make first column into row name
  dc_8 <- tibble::column_to_rownames(dc_8, var="Peptide_id")
  t <- c(1,0,0,1,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1,0,0,1) # adjusted for irregular repeats
  # RAIN analysis
  library(rain)
  rainresult <- rain(t(dc_8), period=8, measure.sequence=t, deltat=1, method='independent')
  return(rainresult)
}


```

### 6.3. RAIN - p_value and peak timepoint: Surface / DCL / BDCL


```{r}
# function to plot p-value
time_series_pvalue <- function(df_filt8,depth="SRF",threshold=0.25){
  rain_SRF8 <-rain_analysis(df_filt8,depth=depth)
  print(sum(rain_SRF8$pVal<=threshold))
  plot((rain_SRF8$pVal) ~ rain_SRF8$phase, xlab="Peak timepoint (Sampling order #)", ylab="p-value",main=paste0("Rhythmic peptides (",depth,")"),cex=2,cex.lab=2, cex.main=2,cex.axis=1.6)
  points(rain_SRF8$pVal[rain_SRF8$pVal<=threshold] ~ rain_SRF8$phase[rain_SRF8$pVal<=threshold], col="red",cex=2)
  abline(h=threshold, col="red")
}

time_series_pvalue(df_filt8,depth="SRF",threshold=0.25)
time_series_pvalue(df_filt8,depth="DCL",threshold=0.25)
time_series_pvalue(df_filt8,depth="BDCL",threshold=0.25)

# draw plots in multigrids
par(mfrow = c(1, 3))
# filtered for 8 timepoint appearing peptides
for (i in 1:length(depth_vec)){
  time_series_pvalue(df_filt8,depth=depth_vec[i],threshold=0.25)
}

# filtered for 7, 8 timepoint appearing peptides
for (i in 1:length(depth_vec)){
  time_series_pvalue(df_filt78,depth=depth_vec[i],threshold=0.25)
}

# change the threshold to 0.15
for (i in 1:length(depth_vec)){
  time_series_pvalue(df_filt8,depth=depth_vec[i],threshold=0.15)
}

for (i in 1:length(depth_vec)){
  time_series_pvalue(df_filt78,depth=depth_vec[i],threshold=0.15)
}

dev.off()


```

### 6.4. Rhythmic peptide's peak time distribution

```{r}
rain_SRF8 <- rain_analysis(df_filt8,depth="SRF") %>% mutate(Depth="SRF") %>% tibble::rownames_to_column(var = "Peptide_id")
rain_DCL8 <- rain_analysis(df_filt8,depth="DCL") %>% mutate(Depth="DCL") %>% tibble::rownames_to_column(var = "Peptide_id")
rain_BDCL8 <- rain_analysis(df_filt8,depth="BDCL") %>% mutate(Depth="BDCL") %>% tibble::rownames_to_column(var = "Peptide_id")
dim(rain_SRF8)
dim(rain_DCL8)
dim(rain_BDCL8)
rain_8 <- rbind(rain_SRF8, rain_DCL8) %>% rbind(rain_BDCL8)
dim(rain_8)
tail(rain_8)

rain_sig <- rain_8 %>% filter(pVal <= 0.25)
rain_sig$Depth <- factor(rain_sig$Depth, levels=depth_vec)

ggplot(rain_sig, aes(x=phase)) +
  geom_freqpoly(binwidth = 1, aes(color=Depth), size=1.5) +
  # geom_histogram(binwidth = 1, position="dodge", aes(fill=Depth)) +
  scale_color_manual(values=cols) +
  ylab("Rhythmic peptide frequency \n") +
  # xlab("\n Peak timepoint (Sampling order #)") +
  xlab("\n Time of day on June 26-27 2019 (Daylight 05:17-20:30)") +
  scale_x_continuous(breaks=seq(1,8,1),labels =c(df_time$date_time))+
  ggtitle(paste0("Histogram of peak time \n"))+
  # scale_x_continuous(breaks=seq(1,8,1)) +
  ## adjust positions
  theme(plot.title = element_text(size = 20,hjust = 0.5, family="serif")) + 
  theme(axis.title.x = element_text(size = 15,hjust = 0.5, family="serif")) + 
  theme(axis.title.y = element_text(size = 15,hjust = 0.5, family="serif")) + 
  theme(axis.text.x = element_text(hjust = 0.9, vjust=0.9,angle=40,size=13, family="serif"))+
  theme(axis.text.y = element_text(size=10)) +
  annotate("rect", xmin = 3.6, xmax = 5.35, ymin = -Inf, ymax = Inf, alpha = .2) +
  theme(panel.grid.minor = element_blank())
  # theme(panel.grid.major = element_blank())

```


### 6.5. Amplitude

```{r}
# Shaping data
rain_sig1 <- rain_8 %>% filter(pVal <= 0.25)
rain_sig1$Peptide_id <- str_replace(rain_sig1$Peptide_id,"P.","Pep_")
rain_sig1$phase <- str_replace(rain_sig1$phase,"^","T")
rain_sig2 <- rain_sig1 %>% rename(Time = phase) %>% select(-period)

# rain_sig2 %>% arrange(Peptide_id)
           
# plot
time_series_1depth_1peak <- function(df_filt8,n=1,time="T1"){
  peak_T1 <- rain_sig2 %>% filter(Time==time) %>% select(Peptide_id)
  print(length(peak_T1$Peptide_id))
  time_series_clust_wError(df_filt8, n, peak_T1$Peptide_id) +
    ggtitle(paste0("Peptides with peak time ",time))+
    theme(axis.title.x = element_text(size = 10,hjust = 0.5, family="serif")) + 
    theme(axis.title.y = element_text(size = 10,hjust = 0.5, family="serif"))
}


# draw histogram in multigrids
library(gridExtra)

# (1) Surface
l <- list()
for (i in paste0("T",1L:8L)){
  print(i)
  l[[i]] <- time_series_1depth_1peak(df_filt8,n=1,time=i)
}
length(l)

grid.arrange(grobs = l, ncol=4)

# (2) DCL
l <- list()
for (i in paste0("T",1L:8L)){
  print(i)
  l[[i]] <- time_series_1depth_1peak(df_filt8,n=2,time=i)
}
length(l)

grid.arrange(grobs = l, ncol=4)

# (3) BDCL
l <- list()
for (i in paste0("T",1L:8L)){
  print(i)
  l[[i]] <- time_series_1depth_1peak(df_filt8,n=3,time=i)
}
length(l)

grid.arrange(grobs = l, ncol=4)



# Getting amplitude
inner_join(rain_sig2, df_ave_rep, by=c("Peptide_id"="Peptide_id","Depth"="Depth","Time"="Time")) %>% dim()



```


















### Archived: Not using this part

Approach2: Time Series Classification using Dynamic time warping distance
Time series classification is to build a classification model based on labelled time series and then use the model to predict the label of unlabelled time series. The way for time series classification with R is to extract and build features from time series data first, and then apply existing classification techniques, such as SVM, k-NN, neural networks, regression and decision trees, to the feature set.

Discrete Wavelet Transform (DWT) provides a multi-resolution representation using wavelets and is used in the example below. Another popular feature extraction technique is Discrete Fourier Transform (DFT).
(http://www.rdatamining.com/examples/time-series-clustering-classification)
```{r eval=F}
# extracting DWT coefficients (with Haar filter)
library(wavelets)
wtData <- NULL

sc <- read.table("data/synthetic_control.data.txt", header=F, sep="")

for (i in 1:nrow(sc)){
  a <- t(sc[i,])
  wt <- dwt(a, filter="haar", boundary='periodic')
  wtData <- rbind(wtData, unlist(c(wt@W,wt@V[[wt@level]])))
}

wtData <- as.data.frame(wtData)
head(wtData)

# set class labels into categorical values
classId <- c(rep(1,100), rep(2,100), rep(3,100),rep(4,100), rep(5,100), rep(6,100))
wtSc <- data.frame(cbind(classId, wtData))

# build a decision tree with ctree() in package party
library(party)
ct <- ctree(classId ~ ., data=wtSc, controls = ctree_control(minsplit=30, minbucket=10, maxdepth=5))
pClassId <- predict(ct)

# check predicted classes against original class labels
table(classId, pClassId)
# accuracy
(sum(classId==pClassId)) / nrow(wtSc)

plot(ct, ip_args=list(pval=FALSE), ep_args=list(digits=0))


# Lower CVI means better clustering : k_shape is the best clustering method
sapply(list(DTW = pc_dtw, DTW_LB = pc_dtwlb, kShape = pc_ks, TADPole = pc_tp), cvi, b = names(l_SRF8), type = "VI")

sapply(list(DTW = pc_dtw, DTW_LB = pc_dtwlb, kShape = pc_ks, TADPole = pc_tp), cvi, type = "internal")


# subset
data <- CharTraj[1L:20L]
pc_k <- tsclust(data, k = 3L:5L, distance = "dtw_basic", centroid = "pam", seed = 94L)
names(pc_k) <- paste0("k_", 3L:5L)
sapply(pc_k, cvi, type = "internal")



names(l_SRF8)
```


5.3. dtwclust
the clustering itself may be shape-based, feature-based or model-based.\
In the context of shape-based time-series clustering, it is common to utilize the Dynamic
Time Warping (DTW) distance as dissimilarity measure (Aghabozorgi et al. 2015).\
DTW is a dynamic programming algorithm that compares two series and tries to find the
optimum warping path between them under certain constraints, such as monotonicity. It
started being used by the data mining community to overcome some of the limitations associated with the Euclidean distance (Ratanamahatana and Keogh 2004; Berndt and Clifford
1994).\
https://cran.r-project.org/web/packages/dtwclust/vignettes/dtwclust.pdf

```{r eval=F}
# install.packages('dtwclust')
# install.packages('TSclust')
library(dtwclust)
require("TSclust")
data("uciCT")

proxy::pr_DB$set_entry(FUN = diss.ACF, names = c("ACFD"), loop = TRUE, type = "metric", distance = TRUE, description = "Autocorrelation-based distance")

# Normalized DTW
ndtw <- function(x, y, ...) {
  dtw(x, y, ...,
  step.pattern = asymmetric,
  distance.only = TRUE)$normalizedDistance
}

# Register the distance with proxy
proxy::pr_DB$set_entry(FUN = ndtw, names = c("nDTW"),
  loop = TRUE, type = "metric", distance = TRUE,
  description = "Normalized, asymmetric DTW")

# Partitional clustering
tsclust(CharTraj[1L:10L], k = 2L,
  distance = "nDTW", seed = 838)

# hierarchical clustering
hc_sbd <- tsclust(CharTraj, type = "h", k = 20L,
  preproc = zscore, seed = 899,
  distance = "sbd", centroid = shape_extraction,
  control = hierarchical_control(method = "average"))

plot(hc_sbd)

# The series and the obtained prototypes can be plotted too
plot(hc_sbd, type = "sc")

# Focusing on the first cluster
plot(hc_sbd, type = "series", clus = 1L)
plot(hc_sbd, type = "centroids", clus = 1L)


### Hierarchical clustering w/ shape based distance
hc_sbd <- tsclust(CharTraj, type = "h", k = 20L,
  preproc = zscore, seed = 899,
  distance = "sbd", centroid = shape_extraction,
  control = hierarchical_control(method = "average"))


### partial clustering methods
# Reinterpolate to same length
data <- reinterpolate(CharTraj, new.length = max(lengths(CharTraj)))

# z-normalization
data <- zscore(data[60L:100L])
names(data)
# DTW method
pc_dtw <- tsclust(data, k = 4L,
  distance = "dtw_basic", centroid = "dba",
  trace = TRUE, seed = 8,
  norm = "L2", window.size = 20L,
  args = tsclust_args(cent = list(trace = TRUE)))

# DTW_lb method
pc_dtwlb <- tsclust(data, k = 4L,
  distance = "dtw_lb", centroid = "dba",
  trace = TRUE, seed = 8,
  norm = "L2", window.size = 20L,
  control = partitional_control(pam.precompute = FALSE),
  args = tsclust_args(cent = list(trace = TRUE)))

# k-shape method
pc_ks <- tsclust(data, k = 4L,
  distance = "sbd", centroid = "shape",
  seed = 8, trace = TRUE)

# Tadpole method
pc_tp <- tsclust(data, k = 4L, type = "t",
  seed = 8, trace = TRUE,
  control = tadpole_control(dc = 1.5,
  window.size = 20L))

# Fuzzy clustering

# Calculate autocorrelation up to 50th lag
acf_fun <- function(series, ...) {
  lapply(series, function(x) {
  as.numeric(acf(x, lag.max = 50, plot = FALSE)$acf)
  })
}
# Fuzzy c-means
fc <- tsclust(CharTraj[1:20], type = "f", k = 4L,
  preproc = acf_fun, distance = "L2",
  seed = 42)

# Lower CVI means better clustering : k_shape is the best clustering method
sapply(list(DTW = pc_dtw, DTW_LB = pc_dtwlb, kShape = pc_ks, TADPole = pc_tp), cvi, b = CharTrajLabels[60L:100L], type = "VI")

CharTraj

# Plot crisp partition in the original space
plot(fc, series = CharTraj[1:20], type = "series")

# subset
data <- CharTraj[1L:20L]
pc_k <- tsclust(data, k = 3L:5L, distance = "dtw_basic", centroid = "pam", seed = 94L)
names(pc_k) <- paste0("k_", 3L:5L)
sapply(pc_k, cvi, type = "internal")

```


6.1. Given code: https://rdrr.io/bioc/rain/f/inst/doc/rain.pdf
```{r}
# BiocManager::install('rain')

set.seed(123)
times <- c(1: 24) * 2
sin <- 1 + 0.5 * sin(times / 24 * 2 * pi) + rnorm(24, 0, 0.3)
saw <- rep(13:24 / 18 , 2) + rnorm(24, 0, 0.3)
measure <- cbind(sin, saw)
require('lattice')
xyplot(t(measure)~rep(times, each=2) | c('sin', 'saw'),layout = c(1, 2), type = 'o', xlab = 'time', ylab = 'value', cex.lab = 0.6)

require(rain)
rainresult <- rain(measure, period=24, deltat=2, peak.border=c(0.1,0.9), verbose=FALSE)
rainresult

data(menetRNASeqMouseLiver)
colnames(menetRNASeqMouseLiver)

results <- rain(t(menetRNASeqMouseLiver), deltat=4, period=24, nr.series=2, peak.border=c(0.3, 0.7), verbose=FALSE)
best <- order(results$pVal)[1:10]
xyplot(as.matrix(menetRNASeqMouseLiver[best, (0:5 * 2 + rep(c(1, 2), each = 6))]) ~rep(0:11 * 4 + 2, each = 10) |rownames(menetRNASeqMouseLiver)[best], scales = list(y = list(relation = 'free')), layout = c(2, 5), type = 'b', pch = 16, xlab = 'time', ylab = 'expression value', cex.lab = 1)


```

