---
title: "peptide_level_visualization"
author: "KiseokUchicago"
date: "2021-02-22"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: console
---

```{r global_options, include=FALSE}
knitr::opts_chunk$set(fig.width=11, fig.height=9,
                      error=TRUE, echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE)
```

### Peptide level visualization

```{r}
# libraries
library(dplyr)
library(tidyr)
library(stringr)
library(ggplot2)
library(formattable)
```

### 1. Quality check: Number of uniq peptides (sequence) per sample

```{r}
# read in combined table of 24 samples (Replicate B)
df_pep <- read.table("Replicate_ABC63_combined.tsv",sep='\t',header = T)

# count unique peptide per sample
df_uni <- df_pep %>% group_by(SampleID) %>% summarize(uniq_pep = length(unique(Base.Peptide.Sequence)))
df_uni1 <- df_uni %>% separate(SampleID, sep='_', into= c('Depth','Time','Replicate'),remove = F) %>% select(-Time, -Replicate)
df_uni2 <- df_uni1 %>% arrange(desc(Depth))

# get the order right from SRF -> DCL -> BDCL
ord <- df_uni2$SampleID 
df_uni2$SampleID <- factor(df_uni2$SampleID, levels = ord)
df_uni2$Depth <- factor(df_uni2$Depth, levels = c('SRF','DCL','BDCL'))

# Making barplot
theme_set(theme_bw())
cols <- c('SRF'='#fc8d62','DCL'='#66c2a5','BDCL'='#8da0cb')
uniq1 <- ggplot(df_uni2, aes(x=SampleID, fill=Depth, y=uniq_pep)) +  ## I put fill=value which was wrong
  geom_bar(stat="identity") +
  scale_fill_manual(values=cols) +
  ylab("Number of unique peptide sequence \n") +
  xlab("\n SampleID") +
  ggtitle("Number of unique peptide sequences per sample")+
  ## adjust positions
  theme(plot.title = element_text(size = 20,hjust = 0.5, family="serif")) + 
  theme(axis.title.x = element_text(size = 15,hjust = 0.5, family="serif")) + 
  theme(axis.title.y = element_text(size = 15,hjust = 0.5, family="serif")) + 
  theme(axis.text.x = element_text(angle = 90, hjust = 0.5, vjust=0.3,size=13, family="serif"))+
  theme(axis.text.y = element_text(size=10))+
  theme(panel.grid.major = element_blank()) +
  theme(panel.grid.minor = element_blank())

uniq2 <- uniq1 + geom_text(aes(x=df_uni$SampleID, y=df_uni$uniq_pep, label=df_uni$uniq_pep),
            size = 3, hjust = 0.5, position = position_stack(vjust = +1.05), family="serif")
uniq2

```

sample DCL_T8 doesn't seem to have good quality MS data. 


### 2. Number of accumulative uniq peptides (sequence): Does it saturate?

```{r}
# read in combined table of 24 samples (Replicate B)
df_pep <- read.table("Replicate_ABC63_combined.tsv",sep='\t',header = T)

# get unique peptides per sample
dt <- df_pep %>% select(SampleID, Base.Peptide.Sequence) %>% unique()
# change SampleID into number
dt1 <- dt %>% select(SampleID) %>% unique() %>% arrange(SampleID) %>%  arrange()
dt2 <- tibble::rownames_to_column(dt1,"depth")
# merge dt and dt2
dt_depth <- left_join(dt,dt2,by=c('SampleID'='SampleID'))
dim(dt_depth)

# get cumulative number of unique peptides (https://stackoverflow.com/questions/15698399/cumulative-count-of-unique-values-in-r)
require(data.table)
dt_depth <- as.data.table(dt_depth)
setkey(dt_depth, "depth")
dt_depth[, Base.Peptide.Sequence := as.numeric(factor(Base.Peptide.Sequence, levels = unique(Base.Peptide.Sequence)))]
setkey(dt_depth, "depth", "Base.Peptide.Sequence")
dt.out <- dt_depth[J(unique(depth)), mult="last"]
dt.out[, Base.Peptide.Sequence := cummax(Base.Peptide.Sequence)]

# getting ready to make plot
df.out <- tibble::rowid_to_column(dt.out) 
df.out2 <- df.out %>% select(rowid, Base.Peptide.Sequence) %>% rename(value=Base.Peptide.Sequence)
# Making line plot
theme_set(theme_bw())

p1 <- ggplot(df.out2,aes(x = rowid,y = value)) + geom_line(col="magenta") + geom_point(color='maroon') +
  ylab("Number of cumulative unique peptide sequence \n") +
  xlab("\n Number of cumulative samples") +
  # ylim(c(0,2200)) +
  ggtitle("Number of cumulative unique peptide sequences \n")+
  ## adjust positions
  theme(plot.title = element_text(size = 20,hjust = 0.5, family="serif")) + 
  theme(axis.title.x = element_text(size = 15,hjust = 0.5, family="serif")) + 
  theme(axis.title.y = element_text(size = 15,hjust = 0.5, family="serif")) + 
  theme(axis.text.x = element_text(hjust = 0.5, vjust=0.3,size=13, family="serif"))+
  theme(axis.text.y = element_text(size=10))
  # theme(panel.grid.major = element_blank())
  # theme(panel.grid.minor = element_blank())

p1


```
It seems to saturate as more samples are added.


### 3. Which Peptide_ids are present in all(almost) time points?
Make a histogram of x-axis being the # of time points present, y-axis being the number of Peptide_ids \
We need 3 histogram for (1) Surface, (2) DCL, and (3) BDCL

```{r}
# read in combined table of 24 samples (Replicate B)
df_pep <- read.table("Replicate_ABC63_combined.tsv",sep='\t',header = T)

# (1) Surface
colnames(df_pep)
df_srf <- df_pep %>% filter(Depth == 'SRF') %>% select(Peptide_id, SampleID, Time, Depth) %>% unique() %>% arrange(Peptide_id)
# How many time points did it appear
(df_srf2 <- df_srf %>% group_by(Peptide_id) %>% summarize(Timepoints = n_distinct(Time)) %>% ungroup())
# Check if Pep_1 appeared in 8 time points
df_srf %>% filter(Peptide_id=="Pep_1004") # true 8 times
# Histogram
theme_set(theme_bw())
ggplot(df_srf2, aes(Timepoints)) + geom_bar() +
  ylab("Number of peptides \n") +
  xlab("\n Cumulative number of timepoints peptide are present") +
  scale_x_continuous(breaks=seq(1,8,1))+
  ggtitle("Distribution of number of timepoints each Peptide_id appears (Surface) \n")+
  ## adjust positions
  theme(plot.title = element_text(size = 20,hjust = 0.5, family="serif")) + 
  theme(axis.title.x = element_text(size = 15,hjust = 0.5, family="serif")) + 
  theme(axis.title.y = element_text(size = 15,hjust = 0.5, family="serif")) + 
  theme(axis.text.x = element_text(hjust = 0.5, vjust=0.3,size=13, family="serif"))+
  theme(axis.text.y = element_text(size=10))
  # theme(panel.grid.major = element_blank())
  # theme(panel.grid.minor = element_blank())

# Let's try to plot all of them at once
df_all <- df_pep %>% select(Peptide_id, SampleID, Time, Depth) %>% unique() %>% arrange(Peptide_id)
# How many time points did it appear
(df_all2 <- df_all %>% group_by(Peptide_id, Depth) %>% summarize(Timepoints = n_distinct(Time)) %>% ungroup())
df_all2$Depth <- factor(df_all2$Depth, levels = c('SRF','DCL','BDCL'))

# Histogram
ggplot(df_all2, aes(Timepoints)) + geom_bar(aes(fill=Depth), position='dodge') +
  scale_fill_manual(values=cols) +
  ylab("Number of peptides \n") +
  xlab("\n Cumulative number of timepoints peptide are present") +
  scale_x_continuous(breaks=seq(1,8,1))+
  ggtitle("Distribution of number of timepoints each Peptide_id appears \n")+
  ## adjust positions
  theme(plot.title = element_text(size = 20,hjust = 0.5, family="serif")) + 
  theme(axis.title.x = element_text(size = 15,hjust = 0.5, family="serif")) + 
  theme(axis.title.y = element_text(size = 15,hjust = 0.5, family="serif")) + 
  theme(axis.text.x = element_text(hjust = 0.5, vjust=0.3,size=13, family="serif"))+
  theme(axis.text.y = element_text(size=10))
  # theme(panel.grid.major = element_blank())
  # theme(panel.grid.minor = element_blank())


```

Why does DCL have so less?

### 4. Plotting time series fluctuation for the peptides
First retrieve the log intensity value for all peptides (average over the same spec_id)

```{r}
# (1) Get list of peptides that are present in 7 or 8 timepoints
df_all2_filt <- df_all2 %>% filter(Timepoints > 6) %>% unique() 

# (2) Let's average the intensity for each unique peptide
df_int <- df_pep %>% select(Peptide_id, Spec_id, log2.18O.16O.Ratio, SampleID, Time, Depth, Replicate) %>% unique() %>% arrange(Peptide_id)
head(df_int)
# first average the spectrum_id per sample 
# important to make sure to take log2 after averaging the original value(2^x)
df_int %>% filter(Peptide_id=='Pep_1' & Time =='T1' & SampleID == 'BDCL_T1_A')
df_ave <- df_int %>% group_by(SampleID, Time, Depth, Replicate, Peptide_id) %>% summarize(log2_Mean_intensity=log2(mean(2^log2.18O.16O.Ratio))) %>% ungroup()
head(df_ave)

df_ave %>% filter(Peptide_id=='Pep_1' & Time =='T1' & SampleID == 'BDCL_T1_A') # check if Pep_1 in sample 'BDCL_T1_A' is -0.5059 (yes correct)

# then average and error by replicate
# see here for calculating error bar in log scale (https://faculty.washington.edu/stuve/log_error.pdf)
# for example of Pep_1
df_ave %>% group_by(SampleID) %>% filter(Peptide_id=='Pep_1') %>% head(10)
# calculate average and error bar for intensity
df_ave_rep <- df_ave %>% group_by(Time, Depth, Peptide_id) %>% summarize(log2_ave_intensity=log2(mean(2^log2_Mean_intensity)), sd_intensity=sd(2^log2_Mean_intensity)) %>% ungroup()
head(df_ave_rep)
# why is there no sd for Pep_1004?
df_ave %>% group_by(SampleID) %>% filter(Peptide_id=='Pep_1004') # there is only 1 sample for T1 BDCL 
# log scale error bar: d(log2y)=1/log2 * (dy / y)
df_ave_rep2 <- df_ave_rep %>% mutate(ave_intensity = 2^log2_ave_intensity) %>% mutate(rel_error = sd_intensity/ave_intensity) %>% mutate(log2_sd_intensity = (1/log(2))*rel_error) %>% mutate(log2_error_up=log2_ave_intensity+log2_sd_intensity) %>% mutate(log2_error_down=log2_ave_intensity-log2_sd_intensity)

head(df_ave_rep2)

# (3) import time metadata and merge
(df_time <- read.table('data/Time_metadata.txt', header=T, sep='\t'))
# left_join with average data
df_ave2 <- df_ave_rep2 %>% left_join(df_time, by=c('Time'='timepoint'))
head(df_ave2)
# only use peptides that appear 7 or 8 times
df_ave2 %>% select(Peptide_id) %>% unique() %>% dim() # 3233 peptides before
df_filt78 <- inner_join(df_ave2, df_all2_filt, by=c('Peptide_id'='Peptide_id','Depth'='Depth'))

# inspecting if the inner join was successful
head(df_filt78)
colnames(df_ave2)
colnames(df_time)
colnames(df_filt78)

df_filt78 %>% select(Peptide_id) %>% unique() %>% dim() # 736 peptides for peptides in 7 or 8 timepoints
df_filt78$Depth <- factor(df_filt78$Depth, levels = c('SRF','DCL','BDCL'))

# get only 8 ones
df_filt8 <- df_filt78 %>% filter(Timepoints > 7)
df_filt8 %>% select(Peptide_id) %>% unique() %>% dim() # 539 peptides for peptides in all 8 timepoints
df_filt8$Depth <- factor(df_filt8$Depth, levels = c('SRF','DCL','BDCL'))

# get only 7 ones
df_filt7 <- df_filt78 %>% filter(Timepoints == 7)
df_filt7 %>% select(Peptide_id) %>% unique() %>% dim() # 533 peptides for peptides in 7 timepoints
df_filt8$Depth <- factor(df_filt8$Depth, levels = c('SRF','DCL','BDCL'))

```

Plot for peptides present in 7 or 8 timepoints
```{r}

# (4) Plot the scatter plot with error bars
theme_set(theme_bw())

ggplot(df_filt78, aes(x=elapsed_hours,y=log2_ave_intensity, color=Depth, group=interaction(Peptide_id,Depth))) +
  geom_point(size=2, shape=21) +
  geom_line()+
  geom_errorbar(aes(ymin=log2_error_down, ymax=log2_error_up), width=.2, position=position_dodge(.9))+
  scale_color_manual(values=cols) +
  ylab("log2 Mean intensity (log2(18O/16O)) \n") +
  xlab("\n Elapsed hours after 12:45pm June 26 2019 (day 05:17-20:30)") +
  scale_x_continuous(breaks=seq(0,26,1))+
  ggtitle("Time series intensity of peptide_id \n")+
  ## adjust positions
  theme(plot.title = element_text(size = 20,hjust = 0.5, family="serif")) + 
  theme(axis.title.x = element_text(size = 15,hjust = 0.5, family="serif")) + 
  theme(axis.title.y = element_text(size = 15,hjust = 0.5, family="serif")) + 
  theme(axis.text.x = element_text(hjust = 0.5, vjust=0.3,size=13, family="serif"))+
  theme(axis.text.y = element_text(size=10)) +
  annotate("rect", xmin = 7.75, xmax = 16.53, ymin = -Inf, ymax = Inf, alpha = .2)
  # geom_rect(aes(xmin=7.75, xmax=16.53, ymin=0, ymax=Inf))
  # theme(panel.grid.major = element_blank()) +
  # theme(panel.grid.minor = element_blank())
```

without error bars
```{r}
theme_set(theme_bw())
ggplot(df_filt78, aes(x=elapsed_hours,y=log2_ave_intensity, color=Depth, group=interaction(Peptide_id,Depth))) +
  geom_point(size=2, shape=21) +
  geom_line()+
  # geom_errorbar(aes(ymin=log2_error_down, ymax=log2_error_up), width=.2, position=position_dodge(.9))+
  scale_color_manual(values=cols) +
  ylab("log2 Mean intensity (log2(18O/16O)) \n") +
  xlab("\n Elapsed hours after 12:45pm June 26 2019 (day 05:17-20:30)") +
  scale_x_continuous(breaks=seq(0,26,1))+
  ggtitle("Time series intensity of peptide_id \n")+
  ## adjust positions
  theme(plot.title = element_text(size = 20,hjust = 0.5, family="serif")) + 
  theme(axis.title.x = element_text(size = 15,hjust = 0.5, family="serif")) + 
  theme(axis.title.y = element_text(size = 15,hjust = 0.5, family="serif")) + 
  theme(axis.text.x = element_text(hjust = 0.5, vjust=0.3,size=13, family="serif"))+
  theme(axis.text.y = element_text(size=10)) +
  annotate("rect", xmin = 7.75, xmax = 16.53, ymin = -Inf, ymax = Inf, alpha = .2)
```


4.1. Surface(SRF)

```{r}
# color code
# 1. Surface(orange): #fc8d62
# 2. DCL(green): #66c2a5
# 3. BDCL(blue): #8da0cb
color_vec <- c('#fc8d62','#66c2a5','#8da0cb')
depth_vec <- c('SRF','DCL','BDCL')

time_series_1depth_woError <- function(df_filt78, depth){
  theme_set(theme_bw())
  # filter depth
  df_filt78_s <- df_filt78 %>% filter(Depth == depth_vec[depth])
  ggplot(df_filt78_s, aes(x=elapsed_hours,y=log2_ave_intensity, group=Peptide_id)) +
    geom_point(size=2, shape=21, color=color_vec[depth]) +
    geom_line(color= color_vec[depth])+
    ylab("Mean log2 intensity (log2(18O/16O)) \n") +
    xlab("\n Elapsed hours after 12:45pm June 26 2019 (day 05:17-20:30)") +
    scale_x_continuous(breaks=seq(0,26,1))+
    ggtitle(paste0("Time series intensity of peptide_id"," (",depth_vec[depth],")","\n"))+
    ## adjust positions
    theme(plot.title = element_text(size = 20,hjust = 0.5, family="serif")) + 
    theme(axis.title.x = element_text(size = 15,hjust = 0.5, family="serif")) + 
    theme(axis.title.y = element_text(size = 15,hjust = 0.5, family="serif")) + 
    theme(axis.text.x = element_text(hjust = 0.5, vjust=0.3,size=13, family="serif"))+
    theme(axis.text.y = element_text(size=10)) +
    annotate("rect", xmin = 7.75, xmax = 16.53, ymin = -Inf, ymax = Inf, alpha = .2)
    # theme(panel.grid.major = element_blank()) +
    # theme(panel.grid.minor = element_blank())
}

time_series_1depth_wError <- function(df_filt78, depth){
  theme_set(theme_bw())
  # filter depth
  df_filt78_s <- df_filt78 %>% filter(Depth == depth_vec[depth])
  ggplot(df_filt78_s, aes(x=elapsed_hours,y=log2_ave_intensity, group=Peptide_id)) +
    geom_point(size=2, shape=21, color=color_vec[depth]) +
    geom_line(color= color_vec[depth])+
    geom_errorbar(aes(ymin=log2_error_down, ymax=log2_error_up), width=.05, position=position_dodge(.2),color='red')+
    ylab("Mean log2 intensity (log2(18O/16O)) \n") +
    xlab("\n Elapsed hours after 12:45pm June 26 2019 (day 05:17-20:30)") +
    scale_x_continuous(breaks=seq(0,26,1))+
    ggtitle(paste0("Time series intensity of peptide_id"," (",depth_vec[depth],")","\n"))+
    ## adjust positions
    theme(plot.title = element_text(size = 20,hjust = 0.5, family="serif")) + 
    theme(axis.title.x = element_text(size = 15,hjust = 0.5, family="serif")) + 
    theme(axis.title.y = element_text(size = 15,hjust = 0.5, family="serif")) + 
    theme(axis.text.x = element_text(hjust = 0.5, vjust=0.3,size=13, family="serif"))+
    theme(axis.text.y = element_text(size=10)) +
    annotate("rect", xmin = 7.75, xmax = 16.53, ymin = -Inf, ymax = Inf, alpha = .2)
    # theme(panel.grid.major = element_blank()) +
    # theme(panel.grid.minor = element_blank())
}

# when we use all 7, 8 appearance cases
time_series_1depth_woError(df_filt78,1)
time_series_1depth_wError(df_filt78,1)

# when we use only 8 appearance cases
time_series_1depth_woError(df_filt8,1)
time_series_1depth_wError(df_filt8,1)

# when we use only 7 appearance cases
time_series_1depth_woError(df_filt7,1)
time_series_1depth_wError(df_filt7,1)

```

4.2. Deep Chlorophyll layer (DCL)

```{r}
# when we use all 7, 8 appearance cases
time_series_1depth_woError(df_filt78,2)
time_series_1depth_wError(df_filt78,2)

# when we use only 8 appearance cases
time_series_1depth_woError(df_filt8,2)
time_series_1depth_wError(df_filt8,2)

# when we use only 7 appearance cases
time_series_1depth_woError(df_filt7,2)
time_series_1depth_wError(df_filt7,2)

```

4.3. Below Deep Chlorophyll layer (BDCL)

```{r}
# when we use all 7, 8 appearance cases
time_series_1depth_woError(df_filt78,3)
time_series_1depth_wError(df_filt78,3)

# when we use only 8 appearance cases
time_series_1depth_woError(df_filt8,3)
time_series_1depth_wError(df_filt8,3)

# when we use only 7 appearance cases
time_series_1depth_woError(df_filt7,3)
time_series_1depth_wError(df_filt7,3)

```

### 5. Time series clustering

For time series clustering with R, the first step is to work out an appropriate distance/similarity metric, and then, at the second step, use existing clustering techniques, such as k-means, hierarchical clustering, density-based clustering or subspace clustering, to find clustering structures.
(http://www.rdatamining.com/examples/time-series-clustering-classification)

5.1. Approach 1: Hierarchical clustering using Dynamic time warping distance
Dynamic Time Warping (DTW) finds optimal alignment between two time series, and DTW distance is used as a distance metric in the example below.
(http://www.rdatamining.com/examples/time-series-clustering-classification)

```{r}

# let's try cluster our time series data
colnames(df_filt8)
df_8 <- df_filt8 %>% filter(Depth=='SRF') %>% select(Peptide_id,Time,log2_ave_intensity)

# reshape the dataframe with timepoints
library(maditr)
v_names <- c("T1","T2","T3","T4","T5","T6","T7","T8")
df_8$Time <- factor(df_8$Time, levels=v_names)
dc_8 <- dcast(df_8, Peptide_id ~ Time, value.var = "log2_ave_intensity")
# make Peptide_id more simpler (Pep_1 -> 1)
dc_8$Peptide_id <- str_replace(dc_8$Peptide_id,"Pep_","")
# make first column into row name
dc_8 <- tibble::column_to_rownames(dc_8, var="Peptide_id")

# DTW distances
library(dtw)
any(is.na(dc_8)) # False: there is no NA in the table
distMatrix <- dist(dc_8, method="DTW")
hc <- hclust(distMatrix, method="average")
plot(hc, cex=0.7, xlab='Hierarchical clustering of Distance(DTW) Matrix')

```

Draw the particular small cluster in the time series plot

```{r}
# function for plotting cluster of piptides
time_series_clust_wError <- function(df_filt78, depth, clust1){
  theme_set(theme_bw())
  # filter depth
  df_filt78_s <- df_filt78 %>% filter(Depth == depth_vec[depth]) %>% filter(Peptide_id %in% clust1)
  ggplot(df_filt78_s, aes(x=elapsed_hours,y=log2_ave_intensity, group=Peptide_id)) +
    geom_point(size=2, shape=21, color=color_vec[depth]) +
    geom_line(color= color_vec[depth])+
    geom_errorbar(aes(ymin=log2_error_down, ymax=log2_error_up), width=.05, position=position_dodge(.2),color='red')+
    ylab("Mean log2 intensity (log2(18O/16O)) \n") +
    xlab("\n Elapsed hours after 12:45pm June 26 2019 (day 05:17-20:30)") +
    scale_x_continuous(breaks=seq(0,26,1))+
    ggtitle(paste0("Time series intensity of peptide_id"," (",depth_vec[depth],")","\n"))+
    ## adjust positions
    theme(plot.title = element_text(size = 20,hjust = 0.5, family="serif")) + 
    theme(axis.title.x = element_text(size = 15,hjust = 0.5, family="serif")) + 
    theme(axis.title.y = element_text(size = 15,hjust = 0.5, family="serif")) + 
    theme(axis.text.x = element_text(hjust = 0.5, vjust=0.3,size=13, family="serif"))+
    theme(axis.text.y = element_text(size=10)) +
    annotate("rect", xmin = 7.75, xmax = 16.53, ymin = -Inf, ymax = Inf, alpha = .2)
    # theme(panel.grid.major = element_blank()) +
    # theme(panel.grid.minor = element_blank())
}

# cluster1
clust1 <- c('149')
clust1 <- str_replace(clust1,"^","Pep_") # make Peptide_id
time_series_clust_wError(df_filt8, 1, clust1)

# cluster2
clust2 <- c("167","216","351","352","96","502","242", "77","110","133", "81","33","539","46","51", "137","264","94","535","18","4", "898", "314", "8")
clust2 <- str_replace(clust2,"^","Pep_") # make Peptide_id
time_series_clust_wError(df_filt8, 1, clust2)

# cluster
clust3 <- c("374","479","758","905","52","435","461","111","196","482","691","597","739","657","740")
clust3 <- str_replace(clust3,"^","Pep_") # make Peptide_id
time_series_clust_wError(df_filt8, 1, clust3)

```

5.2. Unsupervised clustering with various distances (SBD, DTW, ...) / prototyping methods / clustering methods \
- Using dtwclust package
- How many clusters should we use? Evaluate by CVI (Cluster validity index, the bigger the better for internal CVI) \
- Please normalize before clustering

(0) Data formating for tsclust input 

```{r}
# (1) Change our data into list format for input into tsclust
colnames(df_filt8)

make_list <- function(df_filt8,depth){
  df_SRF8 <- df_filt8 %>% filter(Depth==depth) %>% select(Peptide_id,Time,log2_ave_intensity)
  # reshape the dataframe with timepoints
  library(maditr)
  v_names <- c("T1","T2","T3","T4","T5","T6","T7","T8")
  df_SRF8$Time <- factor(df_SRF8$Time, levels=v_names)
  dc_SRF8 <- dcast(df_SRF8, Peptide_id ~ Time, value.var = "log2_ave_intensity")
  # make Peptide_id more simpler (Pep_1 -> P.1)
  dc_SRF8$Peptide_id <- str_replace(dc_SRF8$Peptide_id,"Pep_","P.")
  # make first column into row name
  dc_SRF8 <- tibble::column_to_rownames(dc_SRF8, var="Peptide_id")
  # make it into list format
  # l_SRF8 <- setNames(split(dc_SRF8, seq(nrow(dc_SRF8))), rownames(dc_SRF8))
  l_SRF8 <- as.list(as.data.frame(t(dc_SRF8)))
  return(l_SRF8)
}

l_SRF8 <- make_list(df_filt8,'SRF')
l_DCL8 <- make_list(df_filt8,'DCL')
l_BDCL8 <- make_list(df_filt8,'BDCL')

```

(1) Hierarchical clustering w/ shape based distance

```{r}
# input into tsclust
library(dtwclust)
require("TSclust")

### Hierarchical clustering w/ shape based distance
hc_sbd <- tsclust(l_SRF8, type = "h", k = 2L:10L,
  preproc = zscore, seed = 899,
  distance = "sbd", centroid = shape_extraction,
  control = hierarchical_control(method = "average"))

internal_CVI <- function(hc_sbd,main){
  names(hc_sbd) <- 2L:10L
  (eval <- sapply(hc_sbd, cvi, type = "internal"))
  # divide CH value with 100 just to plot with other internal CVIs 
  eval['CH',] <- eval['CH',]/100
  t(eval)
  matplot(x=seq(2,10,by=1),y=t(eval), type = c("b"),pch=1,col = 1:7,
          xlab="Number of clusters",ylab="Internal CVI (cluster validity index)",main=main,axes=F) #plot
  axis(2)
  axis(side=1,at=2:10)
  legend("bottomright", legend = c("Sil","SF","CH/100","DB","DBstar","D","COP"), col=1:7, pch=1,cex=0.8) # optional legend
}

internal_CVI(hc_sbd,"Hierarchical clustering w/ shape based distance")

# use 3 or 4 clusters
hc_sbd3 <- tsclust(l_SRF8, type = "h", k = 3L,
  distance = "sbd", centroid = shape_extraction,
  control = hierarchical_control(method = "average"))

hc_sbd4 <- tsclust(l_SRF8, type = "h", k = 4L,
  distance = "sbd", centroid = shape_extraction,
  control = hierarchical_control(method = "average"))

# cluster dendrogram
plot(hc_sbd3)
# The series and the obtained prototypes can be plotted too
plot(hc_sbd3, type = "sc")
# Focusing on the first cluster
plot(hc_sbd3, type = "series", clus = 1L)
plot(hc_sbd3, type = "centroids", clus = 1L)

# cluster dendrogram
plot(hc_sbd4)
# The series and the obtained prototypes can be plotted too
plot(hc_sbd4, type = "sc")
```

(2-1) partial clustering methods - DTW

```{r}
### partial clustering methods
# z-normalization
l_SRF8_z <- zscore(l_SRF8)

# DTW distance
pc_dtw <- tsclust(l_SRF8_z, k = 2L:10L,
  distance = "dtw_basic", centroid = "dba",
  trace = TRUE, seed = 8,
  norm = "L2", window.size = 8L,
  args = tsclust_args(cent = list(trace = TRUE)))

internal_CVI(pc_dtw, "Partial clustering with DTW distance")

# use 4, 5, 7 clusters
pc_dtw4 <- tsclust(l_SRF8_z, k = 4L,
  distance = "dtw_basic", centroid = "dba",
  trace = TRUE, seed = 8,
  norm = "L2", window.size = 8L,
  args = tsclust_args(cent = list(trace = TRUE)))
pc_dtw5 <- tsclust(l_SRF8_z, k = 5L,
  distance = "dtw_basic", centroid = "dba",
  trace = TRUE, seed = 8,
  norm = "L2", window.size = 8L,
  args = tsclust_args(cent = list(trace = TRUE)))
pc_dtw7 <- tsclust(l_SRF8_z, k = 7L,
  distance = "dtw_basic", centroid = "dba",
  trace = TRUE, seed = 8,
  norm = "L2", window.size = 8L,
  args = tsclust_args(cent = list(trace = TRUE)))

# Prototypes for 4 clusters
plot(pc_dtw4)

# Prototypes for 5 clusters
plot(pc_dtw5)

# Prototypes for 7 clusters
plot(pc_dtw7)

```

(2-2) partial clustering methods - DTW_lb
cross-distance matrix is NOT symmetric, which can be problematic for

```{r}
# DTW_lb distance method
pc_dtwlb <- tsclust(l_SRF8_z, k = 2L:10L,
  distance = "dtw_lb", centroid = "dba",
  trace = TRUE, seed = 8,
  norm = "L2", window.size = 4L,
  control = partitional_control(pam.precompute = FALSE),
  args = tsclust_args(cent = list(trace = TRUE)))

internal_CVI(pc_dtwlb, "Partial clustering with DTW_lb distance")

# use 8 clusters
pc_dtwlb8 <- tsclust(l_SRF8_z, k = 8L,
  distance = "dtw_lb", centroid = "dba",
  trace = TRUE, seed = 8,
  norm = "L2", window.size = 4L,
  control = partitional_control(pam.precompute = FALSE),
  args = tsclust_args(cent = list(trace = TRUE)))

# Prototypes for 8 clusters
plot(pc_dtwlb8)

```

(2-3) partial clustering methods - k-shape

```{r}
# k-shape method
pc_ks <- tsclust(l_SRF8_z, k = 2L:10L,
  distance = "sbd", centroid = "shape",
  seed = 8, trace = TRUE)

internal_CVI(pc_ks, "Partial clustering with k-shape method")

# use 3 or 4 clusters
pc_ks3 <- tsclust(l_SRF8_z, k = 3L,
  distance = "sbd", centroid = "shape",
  seed = 8, trace = TRUE)

pc_ks4 <- tsclust(l_SRF8_z, k = 4L,
  distance = "sbd", centroid = "shape",
  seed = 8, trace = TRUE)

pc_ks5 <- tsclust(l_SRF8_z, k = 5L,
  distance = "sbd", centroid = "shape",
  seed = 8, trace = TRUE)

# Prototypes for 3 clusters
plot(pc_ks3)

# Prototypes for 4 clusters
plot(pc_ks4)

# Prototypes for 5 clusters
plot(pc_ks5)
```


(2-4) partial clustering methods - Tadpole 
problematic for our dataset (series' cross-distance matrix is NOT symmetric)

```{r}
# Tadpole method
pc_tp <- tsclust(l_SRF8_z, k = 2L:10L, type = "t",
  seed = 8, trace = TRUE,
  control = tadpole_control(dc = 1.5,
  window.size = 4L))

internal_CVI(pc_tp, "Partial clustering with Tadpole method")

# use 8 clusters
pc_tp8 <- tsclust(l_SRF8_z, k = 8L, type = "t",
  seed = 8, trace = TRUE,
  control = tadpole_control(dc = 1.5,
  window.size = 4L))

# Prototypes for 8 clusters
plot(pc_tp8)

```

### 6. RAIN analysis (Rhythmicity Analysis Incorporating Non-parametric methods)

```{r}
require(rain)











```



















### Archived: Not using this part

Approach2: Time Series Classification using Dynamic time warping distance
Time series classification is to build a classification model based on labelled time series and then use the model to predict the label of unlabelled time series. The way for time series classification with R is to extract and build features from time series data first, and then apply existing classification techniques, such as SVM, k-NN, neural networks, regression and decision trees, to the feature set.

Discrete Wavelet Transform (DWT) provides a multi-resolution representation using wavelets and is used in the example below. Another popular feature extraction technique is Discrete Fourier Transform (DFT).
(http://www.rdatamining.com/examples/time-series-clustering-classification)
```{r eval=F}
# extracting DWT coefficients (with Haar filter)
library(wavelets)
wtData <- NULL

sc <- read.table("data/synthetic_control.data.txt", header=F, sep="")

for (i in 1:nrow(sc)){
  a <- t(sc[i,])
  wt <- dwt(a, filter="haar", boundary='periodic')
  wtData <- rbind(wtData, unlist(c(wt@W,wt@V[[wt@level]])))
}

wtData <- as.data.frame(wtData)
head(wtData)

# set class labels into categorical values
classId <- c(rep(1,100), rep(2,100), rep(3,100),rep(4,100), rep(5,100), rep(6,100))
wtSc <- data.frame(cbind(classId, wtData))

# build a decision tree with ctree() in package party
library(party)
ct <- ctree(classId ~ ., data=wtSc, controls = ctree_control(minsplit=30, minbucket=10, maxdepth=5))
pClassId <- predict(ct)

# check predicted classes against original class labels
table(classId, pClassId)
# accuracy
(sum(classId==pClassId)) / nrow(wtSc)

plot(ct, ip_args=list(pval=FALSE), ep_args=list(digits=0))


# Lower CVI means better clustering : k_shape is the best clustering method
sapply(list(DTW = pc_dtw, DTW_LB = pc_dtwlb, kShape = pc_ks, TADPole = pc_tp), cvi, b = names(l_SRF8), type = "VI")

sapply(list(DTW = pc_dtw, DTW_LB = pc_dtwlb, kShape = pc_ks, TADPole = pc_tp), cvi, type = "internal")


# subset
data <- CharTraj[1L:20L]
pc_k <- tsclust(data, k = 3L:5L, distance = "dtw_basic", centroid = "pam", seed = 94L)
names(pc_k) <- paste0("k_", 3L:5L)
sapply(pc_k, cvi, type = "internal")



names(l_SRF8)
```


### Archived: 5.3. dtwclust
the clustering itself may be shape-based, feature-based or model-based.\
In the context of shape-based time-series clustering, it is common to utilize the Dynamic
Time Warping (DTW) distance as dissimilarity measure (Aghabozorgi et al. 2015).\
DTW is a dynamic programming algorithm that compares two series and tries to find the
optimum warping path between them under certain constraints, such as monotonicity. It
started being used by the data mining community to overcome some of the limitations associated with the Euclidean distance (Ratanamahatana and Keogh 2004; Berndt and Clifford
1994).\
https://cran.r-project.org/web/packages/dtwclust/vignettes/dtwclust.pdf

```{r eval=F}
# install.packages('dtwclust')
# install.packages('TSclust')
library(dtwclust)
require("TSclust")
data("uciCT")

proxy::pr_DB$set_entry(FUN = diss.ACF, names = c("ACFD"), loop = TRUE, type = "metric", distance = TRUE, description = "Autocorrelation-based distance")

# Normalized DTW
ndtw <- function(x, y, ...) {
  dtw(x, y, ...,
  step.pattern = asymmetric,
  distance.only = TRUE)$normalizedDistance
}

# Register the distance with proxy
proxy::pr_DB$set_entry(FUN = ndtw, names = c("nDTW"),
  loop = TRUE, type = "metric", distance = TRUE,
  description = "Normalized, asymmetric DTW")

# Partitional clustering
tsclust(CharTraj[1L:10L], k = 2L,
  distance = "nDTW", seed = 838)

# hierarchical clustering
hc_sbd <- tsclust(CharTraj, type = "h", k = 20L,
  preproc = zscore, seed = 899,
  distance = "sbd", centroid = shape_extraction,
  control = hierarchical_control(method = "average"))

plot(hc_sbd)

# The series and the obtained prototypes can be plotted too
plot(hc_sbd, type = "sc")

# Focusing on the first cluster
plot(hc_sbd, type = "series", clus = 1L)
plot(hc_sbd, type = "centroids", clus = 1L)


### Hierarchical clustering w/ shape based distance
hc_sbd <- tsclust(CharTraj, type = "h", k = 20L,
  preproc = zscore, seed = 899,
  distance = "sbd", centroid = shape_extraction,
  control = hierarchical_control(method = "average"))


### partial clustering methods
# Reinterpolate to same length
data <- reinterpolate(CharTraj, new.length = max(lengths(CharTraj)))

# z-normalization
data <- zscore(data[60L:100L])
names(data)
# DTW method
pc_dtw <- tsclust(data, k = 4L,
  distance = "dtw_basic", centroid = "dba",
  trace = TRUE, seed = 8,
  norm = "L2", window.size = 20L,
  args = tsclust_args(cent = list(trace = TRUE)))

# DTW_lb method
pc_dtwlb <- tsclust(data, k = 4L,
  distance = "dtw_lb", centroid = "dba",
  trace = TRUE, seed = 8,
  norm = "L2", window.size = 20L,
  control = partitional_control(pam.precompute = FALSE),
  args = tsclust_args(cent = list(trace = TRUE)))

# k-shape method
pc_ks <- tsclust(data, k = 4L,
  distance = "sbd", centroid = "shape",
  seed = 8, trace = TRUE)

# Tadpole method
pc_tp <- tsclust(data, k = 4L, type = "t",
  seed = 8, trace = TRUE,
  control = tadpole_control(dc = 1.5,
  window.size = 20L))

# Fuzzy clustering

# Calculate autocorrelation up to 50th lag
acf_fun <- function(series, ...) {
  lapply(series, function(x) {
  as.numeric(acf(x, lag.max = 50, plot = FALSE)$acf)
  })
}
# Fuzzy c-means
fc <- tsclust(CharTraj[1:20], type = "f", k = 4L,
  preproc = acf_fun, distance = "L2",
  seed = 42)

# Lower CVI means better clustering : k_shape is the best clustering method
sapply(list(DTW = pc_dtw, DTW_LB = pc_dtwlb, kShape = pc_ks, TADPole = pc_tp), cvi, b = CharTrajLabels[60L:100L], type = "VI")

CharTraj

# Plot crisp partition in the original space
plot(fc, series = CharTraj[1:20], type = "series")

# subset
data <- CharTraj[1L:20L]
pc_k <- tsclust(data, k = 3L:5L, distance = "dtw_basic", centroid = "pam", seed = 94L)
names(pc_k) <- paste0("k_", 3L:5L)
sapply(pc_k, cvi, type = "internal")

```

